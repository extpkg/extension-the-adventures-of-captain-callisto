<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Captain Callisto</title>
    <style>
      * {
        touch-action: none;
      }
      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        border: 0;
        overflow: hidden;
        display: block;
        background: #000;
      }
      canvas {
        position: absolute;
      }
      #frame {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 32px;
        background-color: transparent;
        z-index: 2;
        -webkit-app-region: drag;
      }
    </style>
  </head>
  <body>
    <div id="frame"></div>
    <canvas></canvas>
    <canvas></canvas>
    <script>
      const DEBUG = false;
      function log(str) {
        if (DEBUG) console.log(str);
      }
      const buildShortcut = (name) =>
        name.substr(0, 3) + name.substr(-3) + (name[name.length - 8] || "_");
      const buildShortcuts = (obj) => {
        for (const key in obj) {
          const s = buildShortcut(key);
          if (!(s in obj)) {
            log(`Shortcut '${s}' for '${key}'`);
            obj[s] = obj[key];
          }
        }
      };
      const icon = "\ud83d\udc68\u200d\ud83d\ude80";
      const gameName = "Captain Callisto";
      const addTrophy = (trophyName, message = "") => {
        localStorage[`Trophy,${icon},${gameName},${trophyName}`] = message;
      };
      const registerSong = (songName, song) => {
        localStorage[`Music,${songName}`] = JSON.stringify(song);
      };
      class RNG {
        constructor(seed) {
          this.m = 2147483648;
          this.a = 1103515245;
          this.c = 12345;
          this.state = seed;
        }
        nextInt() {
          this.state = (this.a * this.state + this.c) % this.m;
          return this.state;
        }
        nextFloat() {
          return this.nextInt() / (this.m - 1);
        }
        nextRange(start, end) {
          const rangeSize = end - start;
          const randomUnder1 = this.nextInt() / this.m;
          return start + ((randomUnder1 * rangeSize) | 0);
        }
      }
      const vec3 = {};
      vec3.create = () => new Float32Array(3);
      vec3.clone = (a) => new Float32Array(a);
      vec3.magnitude = (a) => Math.hypot(a[0], a[1], a[2]);
      vec3.fromValues = (x, y, z) => new Float32Array([x, y, z]);
      vec3.copy = (out, a) => {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        return out;
      };
      vec3.set = (out, x, y, z) => {
        out[0] = x;
        out[1] = y;
        out[2] = z;
        return out;
      };
      vec3.add = (out, a, b) => {
        out[0] = a[0] + b[0];
        out[1] = a[1] + b[1];
        out[2] = a[2] + b[2];
        return out;
      };
      vec3.subtract = (out, a, b) => {
        out[0] = a[0] - b[0];
        out[1] = a[1] - b[1];
        out[2] = a[2] - b[2];
        return out;
      };
      vec3.multiply = (out, a, b) => {
        out[0] = a[0] * b[0];
        out[1] = a[1] * b[1];
        out[2] = a[2] * b[2];
        return out;
      };
      vec3.divide = (out, a, b) => {
        out[0] = a[0] / b[0];
        out[1] = a[1] / b[1];
        out[2] = a[2] / b[2];
        return out;
      };
      vec3.ceil = (out, a) => {
        out[0] = Math.ceil(a[0]);
        out[1] = Math.ceil(a[1]);
        out[2] = Math.ceil(a[2]);
        return out;
      };
      vec3.min = (out, a, b) => {
        out[0] = Math.min(a[0], b[0]);
        out[1] = Math.min(a[1], b[1]);
        out[2] = Math.min(a[2], b[2]);
        return out;
      };
      vec3.max = (out, a, b) => {
        out[0] = Math.max(a[0], b[0]);
        out[1] = Math.max(a[1], b[1]);
        out[2] = Math.max(a[2], b[2]);
        return out;
      };
      vec3.scale = (out, a, b) => {
        out[0] = a[0] * b;
        out[1] = a[1] * b;
        out[2] = a[2] * b;
        return out;
      };
      vec3.scaleAndAdd = (out, a, b, scale) => {
        out[0] = a[0] + b[0] * scale;
        out[1] = a[1] + b[1] * scale;
        out[2] = a[2] + b[2] * scale;
        return out;
      };
      vec3.distance = (a, b) => {
        const x = b[0] - a[0];
        const y = b[1] - a[1];
        const z = b[2] - a[2];
        return Math.hypot(x, y, z);
      };
      vec3.squaredDistance = (a, b) => {
        const x = b[0] - a[0];
        const y = b[1] - a[1];
        const z = b[2] - a[2];
        return x * x + y * y + z * z;
      };
      vec3.squaredLength = (a) => {
        const x = a[0];
        const y = a[1];
        const z = a[2];
        return x * x + y * y + z * z;
      };
      vec3.negate = (out, a) => {
        out[0] = -a[0];
        out[1] = -a[1];
        out[2] = -a[2];
        return out;
      };
      vec3.inverse = (out, a) => {
        out[0] = 1 / a[0];
        out[1] = 1 / a[1];
        out[2] = 1 / a[2];
        return out;
      };
      vec3.normalize = (out, a) => {
        const len = vec3.magnitude(a);
        return len > 0 ? vec3.scale(out, a, 1 / len) : vec3.copy(out, a);
      };
      vec3.dot = (a, b) => {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
      };
      vec3.cross = (out, a, b) => {
        const ax = a[0];
        const ay = a[1];
        const az = a[2];
        const bx = b[0];
        const by = b[1];
        const bz = b[2];
        out[0] = ay * bz - az * by;
        out[1] = az * bx - ax * bz;
        out[2] = ax * by - ay * bx;
        return out;
      };
      vec3.cross2 = (out, origin, a, b) => {
        const ax = a[0] - origin[0];
        const ay = a[1] - origin[1];
        const az = a[2] - origin[2];
        const bx = b[0] - origin[0];
        const by = b[1] - origin[1];
        const bz = b[2] - origin[2];
        out[0] = ay * bz - az * by;
        out[1] = az * bx - ax * bz;
        out[2] = ax * by - ay * bx;
        return out;
      };
      vec3.lerp = (out, a, b, t) => {
        out[0] = a[0] + t * (b[0] - a[0]);
        out[1] = a[1] + t * (b[1] - a[1]);
        out[2] = a[2] + t * (b[2] - a[2]);
        return out;
      };
      vec3.transformMat4 = (out, a, m) => {
        const x = a[0];
        const y = a[1];
        const z = a[2];
        let w = m[3] * x + m[7] * y + m[11] * z + m[15];
        w = w || 1;
        out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
        out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
        out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
        return out;
      };
      vec3.rotateX = (out, a, b, c) => {
        const p = [];
        const r = [];
        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2];
        r[0] = p[0];
        r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
        r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);
        out[0] = r[0] + b[0];
        out[1] = r[1] + b[1];
        out[2] = r[2] + b[2];
        return out;
      };
      vec3.rotateY = (out, a, b, c) => {
        const p = [];
        const r = [];
        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2];
        r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
        r[1] = p[1];
        r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);
        out[0] = r[0] + b[0];
        out[1] = r[1] + b[1];
        out[2] = r[2] + b[2];
        return out;
      };
      vec3.rotateZ = (out, a, b, c) => {
        const p = [];
        const r = [];
        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2];
        r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
        r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
        r[2] = p[2];
        out[0] = r[0] + b[0];
        out[1] = r[1] + b[1];
        out[2] = r[2] + b[2];
        return out;
      };
      vec3.angle = (a, b) => {
        const tempA = vec3.fromValues(a[0], a[1], a[2]);
        const tempB = vec3.fromValues(b[0], b[1], b[2]);
        vec3.normalize(tempA, tempA);
        vec3.normalize(tempB, tempB);
        const cosine = vec3.dot(tempA, tempB);
        if (cosine > 1) return 0;
        else if (cosine < -1) return Math.PI;
        else return Math.acos(cosine);
      };
      vec3.str = (a) => {
        return (
          "vec3(" +
          a[0].toFixed(4) +
          ", " +
          a[1].toFixed(4) +
          ", " +
          a[2].toFixed(4) +
          ")"
        );
      };
      vec3.exactEquals = (a, b) => {
        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
      };
      vec3.equals = (a, b) => {
        const a0 = a[0];
        const a1 = a[1];
        const a2 = a[2];
        const b0 = b[0];
        const b1 = b[1];
        const b2 = b[2];
        return (
          Math.abs(a0 - b0) <=
            EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <=
            EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2))
        );
      };
      const mat4 = {};
      mat4.create = () => {
        const out = new Float32Array(16);
        out[0] = 1;
        out[5] = 1;
        out[10] = 1;
        out[15] = 1;
        return out;
      };
      mat4.clone = (a) => {
        const out = new Float32Array(16);
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
        return out;
      };
      mat4.copy = (out, a) => {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
        return out;
      };
      mat4.fromValues = (
        m00,
        m01,
        m02,
        m03,
        m10,
        m11,
        m12,
        m13,
        m20,
        m21,
        m22,
        m23,
        m30,
        m31,
        m32,
        m33,
      ) => {
        const out = new Float32Array(16);
        out[0] = m00;
        out[1] = m01;
        out[2] = m02;
        out[3] = m03;
        out[4] = m10;
        out[5] = m11;
        out[6] = m12;
        out[7] = m13;
        out[8] = m20;
        out[9] = m21;
        out[10] = m22;
        out[11] = m23;
        out[12] = m30;
        out[13] = m31;
        out[14] = m32;
        out[15] = m33;
        return out;
      };
      mat4.set = (
        out,
        m00,
        m01,
        m02,
        m03,
        m10,
        m11,
        m12,
        m13,
        m20,
        m21,
        m22,
        m23,
        m30,
        m31,
        m32,
        m33,
      ) => {
        out[0] = m00;
        out[1] = m01;
        out[2] = m02;
        out[3] = m03;
        out[4] = m10;
        out[5] = m11;
        out[6] = m12;
        out[7] = m13;
        out[8] = m20;
        out[9] = m21;
        out[10] = m22;
        out[11] = m23;
        out[12] = m30;
        out[13] = m31;
        out[14] = m32;
        out[15] = m33;
        return out;
      };
      mat4.identity = (out) => {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      };
      mat4.transpose = (out, a) => {
        if (out === a) {
          const a01 = a[1];
          const a02 = a[2];
          const a03 = a[3];
          const a12 = a[6];
          const a13 = a[7];
          const a23 = a[11];
          out[1] = a[4];
          out[2] = a[8];
          out[3] = a[12];
          out[4] = a01;
          out[6] = a[9];
          out[7] = a[13];
          out[8] = a02;
          out[9] = a12;
          out[11] = a[14];
          out[12] = a03;
          out[13] = a13;
          out[14] = a23;
        } else {
          out[0] = a[0];
          out[1] = a[4];
          out[2] = a[8];
          out[3] = a[12];
          out[4] = a[1];
          out[5] = a[5];
          out[6] = a[9];
          out[7] = a[13];
          out[8] = a[2];
          out[9] = a[6];
          out[10] = a[10];
          out[11] = a[14];
          out[12] = a[3];
          out[13] = a[7];
          out[14] = a[11];
          out[15] = a[15];
        }
        return out;
      };
      mat4.invert = (out, a) => {
        const a00 = a[0];
        const a01 = a[1];
        const a02 = a[2];
        const a03 = a[3];
        const a10 = a[4];
        const a11 = a[5];
        const a12 = a[6];
        const a13 = a[7];
        const a20 = a[8];
        const a21 = a[9];
        const a22 = a[10];
        const a23 = a[11];
        const a30 = a[12];
        const a31 = a[13];
        const a32 = a[14];
        const a33 = a[15];
        const b00 = a00 * a11 - a01 * a10;
        const b01 = a00 * a12 - a02 * a10;
        const b02 = a00 * a13 - a03 * a10;
        const b03 = a01 * a12 - a02 * a11;
        const b04 = a01 * a13 - a03 * a11;
        const b05 = a02 * a13 - a03 * a12;
        const b06 = a20 * a31 - a21 * a30;
        const b07 = a20 * a32 - a22 * a30;
        const b08 = a20 * a33 - a23 * a30;
        const b09 = a21 * a32 - a22 * a31;
        const b10 = a21 * a33 - a23 * a31;
        const b11 = a22 * a33 - a23 * a32;
        let det =
          b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) return null;
        det = 1 / det;
        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
        out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
        out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
        out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
        out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
        out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
        out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
        return out;
      };
      mat4.multiply = (out, a, b) => {
        const a00 = a[0];
        const a01 = a[1];
        const a02 = a[2];
        const a03 = a[3];
        const a10 = a[4];
        const a11 = a[5];
        const a12 = a[6];
        const a13 = a[7];
        const a20 = a[8];
        const a21 = a[9];
        const a22 = a[10];
        const a23 = a[11];
        const a30 = a[12];
        const a31 = a[13];
        const a32 = a[14];
        const a33 = a[15];
        let b0 = b[0];
        let b1 = b[1];
        let b2 = b[2];
        let b3 = b[3];
        out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b[4];
        b1 = b[5];
        b2 = b[6];
        b3 = b[7];
        out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b[8];
        b1 = b[9];
        b2 = b[10];
        b3 = b[11];
        out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b[12];
        b1 = b[13];
        b2 = b[14];
        b3 = b[15];
        out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        return out;
      };
      mat4.translate = (out, a, v) => {
        const x = v[0];
        const y = v[1];
        const z = v[2];
        let a00 = void 0;
        let a01 = void 0;
        let a02 = void 0;
        let a03 = void 0;
        let a10 = void 0;
        let a11 = void 0;
        let a12 = void 0;
        let a13 = void 0;
        let a20 = void 0;
        let a21 = void 0;
        let a22 = void 0;
        let a23 = void 0;
        if (a === out) {
          out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
          out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
          out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
          out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
        } else {
          a00 = a[0];
          a01 = a[1];
          a02 = a[2];
          a03 = a[3];
          a10 = a[4];
          a11 = a[5];
          a12 = a[6];
          a13 = a[7];
          a20 = a[8];
          a21 = a[9];
          a22 = a[10];
          a23 = a[11];
          out[0] = a00;
          out[1] = a01;
          out[2] = a02;
          out[3] = a03;
          out[4] = a10;
          out[5] = a11;
          out[6] = a12;
          out[7] = a13;
          out[8] = a20;
          out[9] = a21;
          out[10] = a22;
          out[11] = a23;
          out[12] = a00 * x + a10 * y + a20 * z + a[12];
          out[13] = a01 * x + a11 * y + a21 * z + a[13];
          out[14] = a02 * x + a12 * y + a22 * z + a[14];
          out[15] = a03 * x + a13 * y + a23 * z + a[15];
        }
        return out;
      };
      mat4.scale = (out, a, v) => {
        const x = v[0];
        const y = v[1];
        const z = v[2];
        out[0] = a[0] * x;
        out[1] = a[1] * x;
        out[2] = a[2] * x;
        out[3] = a[3] * x;
        out[4] = a[4] * y;
        out[5] = a[5] * y;
        out[6] = a[6] * y;
        out[7] = a[7] * y;
        out[8] = a[8] * z;
        out[9] = a[9] * z;
        out[10] = a[10] * z;
        out[11] = a[11] * z;
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
        return out;
      };
      mat4.rotate = (out, a, rad, axis) => {
        let x = axis[0];
        let y = axis[1];
        let z = axis[2];
        let len = Math.sqrt(x * x + y * y + z * z);
        let s = void 0;
        let c = void 0;
        let t = void 0;
        let a00 = void 0;
        let a01 = void 0;
        let a02 = void 0;
        let a03 = void 0;
        let a10 = void 0;
        let a11 = void 0;
        let a12 = void 0;
        let a13 = void 0;
        let a20 = void 0;
        let a21 = void 0;
        let a22 = void 0;
        let a23 = void 0;
        let b00 = void 0;
        let b01 = void 0;
        let b02 = void 0;
        let b10 = void 0;
        let b11 = void 0;
        let b12 = void 0;
        let b20 = void 0;
        let b21 = void 0;
        let b22 = void 0;
        if (Math.abs(len) < EPSILON) return null;
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        s = Math.sin(rad);
        c = Math.cos(rad);
        t = 1 - c;
        a00 = a[0];
        a01 = a[1];
        a02 = a[2];
        a03 = a[3];
        a10 = a[4];
        a11 = a[5];
        a12 = a[6];
        a13 = a[7];
        a20 = a[8];
        a21 = a[9];
        a22 = a[10];
        a23 = a[11];
        b00 = x * x * t + c;
        b01 = y * x * t + z * s;
        b02 = z * x * t - y * s;
        b10 = x * y * t - z * s;
        b11 = y * y * t + c;
        b12 = z * y * t + x * s;
        b20 = x * z * t + y * s;
        b21 = y * z * t - x * s;
        b22 = z * z * t + c;
        out[0] = a00 * b00 + a10 * b01 + a20 * b02;
        out[1] = a01 * b00 + a11 * b01 + a21 * b02;
        out[2] = a02 * b00 + a12 * b01 + a22 * b02;
        out[3] = a03 * b00 + a13 * b01 + a23 * b02;
        out[4] = a00 * b10 + a10 * b11 + a20 * b12;
        out[5] = a01 * b10 + a11 * b11 + a21 * b12;
        out[6] = a02 * b10 + a12 * b11 + a22 * b12;
        out[7] = a03 * b10 + a13 * b11 + a23 * b12;
        out[8] = a00 * b20 + a10 * b21 + a20 * b22;
        out[9] = a01 * b20 + a11 * b21 + a21 * b22;
        out[10] = a02 * b20 + a12 * b21 + a22 * b22;
        out[11] = a03 * b20 + a13 * b21 + a23 * b22;
        if (a !== out) {
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
        }
        return out;
      };
      mat4.rotateX = (out, a, rad) => {
        const s = Math.sin(rad);
        const c = Math.cos(rad);
        const a10 = a[4];
        const a11 = a[5];
        const a12 = a[6];
        const a13 = a[7];
        const a20 = a[8];
        const a21 = a[9];
        const a22 = a[10];
        const a23 = a[11];
        if (a !== out) {
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
        }
        out[4] = a10 * c + a20 * s;
        out[5] = a11 * c + a21 * s;
        out[6] = a12 * c + a22 * s;
        out[7] = a13 * c + a23 * s;
        out[8] = a20 * c - a10 * s;
        out[9] = a21 * c - a11 * s;
        out[10] = a22 * c - a12 * s;
        out[11] = a23 * c - a13 * s;
        return out;
      };
      mat4.rotateY = (out, a, rad) => {
        const s = Math.sin(rad);
        const c = Math.cos(rad);
        const a00 = a[0];
        const a01 = a[1];
        const a02 = a[2];
        const a03 = a[3];
        const a20 = a[8];
        const a21 = a[9];
        const a22 = a[10];
        const a23 = a[11];
        if (a !== out) {
          out[4] = a[4];
          out[5] = a[5];
          out[6] = a[6];
          out[7] = a[7];
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
        }
        out[0] = a00 * c - a20 * s;
        out[1] = a01 * c - a21 * s;
        out[2] = a02 * c - a22 * s;
        out[3] = a03 * c - a23 * s;
        out[8] = a00 * s + a20 * c;
        out[9] = a01 * s + a21 * c;
        out[10] = a02 * s + a22 * c;
        out[11] = a03 * s + a23 * c;
        return out;
      };
      mat4.rotateZ = (out, a, rad) => {
        const s = Math.sin(rad);
        const c = Math.cos(rad);
        const a00 = a[0];
        const a01 = a[1];
        const a02 = a[2];
        const a03 = a[3];
        const a10 = a[4];
        const a11 = a[5];
        const a12 = a[6];
        const a13 = a[7];
        if (a !== out) {
          out[8] = a[8];
          out[9] = a[9];
          out[10] = a[10];
          out[11] = a[11];
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
        }
        out[0] = a00 * c + a10 * s;
        out[1] = a01 * c + a11 * s;
        out[2] = a02 * c + a12 * s;
        out[3] = a03 * c + a13 * s;
        out[4] = a10 * c - a00 * s;
        out[5] = a11 * c - a01 * s;
        out[6] = a12 * c - a02 * s;
        out[7] = a13 * c - a03 * s;
        return out;
      };
      mat4.getTranslation = (out, mat) => {
        out[0] = mat[12];
        out[1] = mat[13];
        out[2] = mat[14];
        return out;
      };
      mat4.perspective = (out, fovy, aspect, near, far) => {
        const f = 1 / Math.tan(fovy / 2);
        const nf = 1 / (near - far);
        out[0] = f / aspect;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = f;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = -(far + near) * nf;
        out[11] = 1;
        out[12] = 0;
        out[13] = 0;
        out[14] = 2 * far * near * nf;
        out[15] = 0;
        return out;
      };
      const buildRoundedCube = (n, maxRadius) => {
        const data = [];
        const p1 = vec3.fromValues(-1, 1, -1);
        const p2 = vec3.fromValues(1, 1, -1);
        const p3 = vec3.fromValues(1, 1, 1);
        const p4 = vec3.fromValues(-1, 1, 1);
        const p5 = vec3.fromValues(-1, -1, -1);
        const p6 = vec3.fromValues(1, -1, -1);
        const p7 = vec3.fromValues(1, -1, 1);
        const p8 = vec3.fromValues(-1, -1, 1);
        const di = vec3.create();
        const dj = vec3.create();
        const tmp1 = vec3.create();
        const tmp2 = vec3.create();
        const tmp3 = vec3.create();
        const tmp4 = vec3.create();
        const buildFace = (origin, topRight, bottomLeft) => {
          vec3.subtract(di, topRight, origin);
          vec3.subtract(dj, bottomLeft, origin);
          const buildPoint = (out, i, j) => {
            vec3.scaleAndAdd(out, origin, di, i / n);
            vec3.scaleAndAdd(out, out, dj, j / n);
            const len = vec3.magnitude(out);
            if (len > maxRadius) vec3.scale(out, out, maxRadius / len);
          };
          for (let i = 0; i < n; i++)
            for (let j = 0; j < n; j++) {
              buildPoint(tmp1, i, j);
              buildPoint(tmp2, i + 1, j);
              buildPoint(tmp3, i + 1, j + 1);
              buildPoint(tmp4, i, j + 1);
              addQuad(data, tmp1, tmp2, tmp3, tmp4);
            }
        };
        buildFace(p1, p2, p4);
        buildFace(p8, p7, p5);
        buildFace(p2, p1, p6);
        buildFace(p4, p3, p8);
        buildFace(p1, p4, p5);
        buildFace(p3, p2, p7);
        return new Float32Array(data);
      };
      const addQuad = (data, p1, p2, p3, p4) => {
        addTriangle(data, p1, p2, p3);
        addTriangle(data, p1, p3, p4);
      };
      const addTriangle = (data, p1, p2, p3) => {
        addPoint(data, p1);
        addPoint(data, p2);
        addPoint(data, p3);
      };
      const addPoint = (data, p) => data.push(...p);
      const BYTES_PER_COMPONENT = 4;
      const COMPONENTS_PER_VERTEX = 3;
      const BYTES_PER_VERTEX = COMPONENTS_PER_VERTEX * BYTES_PER_COMPONENT;
      const COMPONENTS_PER_MATRIX = 4 * 4;
      const BYTES_PER_MATRIX = COMPONENTS_PER_MATRIX * BYTES_PER_COMPONENT;
      const COMPONENTS_PER_INSTANCE = 1 + COMPONENTS_PER_MATRIX;
      const BYTES_PER_INSTANCE = COMPONENTS_PER_INSTANCE * BYTES_PER_COMPONENT;
      let GLenum;
      class BufferSet {
        constructor(usage, geometry, maxInstances) {
          this.usage = usage;
          this.verticesPerInstance = geometry.length / COMPONENTS_PER_VERTEX;
          this.instanceCount = 0;
          this.vao = gl.createVertexArray();
          gl.binrayt(this.vao);
          this.geometryBuffer = gl.createBuffer();
          gl.binfern(ARRAY_BUFFER, this.geometryBuffer);
          gl.bufataf(ARRAY_BUFFER, geometry, STATIC_DRAW);
          gl.enarayr(positionAttrib);
          gl.verterb(positionAttrib, 3, FLOAT, false, BYTES_PER_VERTEX, 0);
          this.instanceData = new Uint32Array(
            maxInstances * COMPONENTS_PER_INSTANCE,
          );
          this.instanceBuffer = gl.createBuffer();
          gl.binfern(ARRAY_BUFFER, this.instanceBuffer);
          gl.bufataf(ARRAY_BUFFER, this.instanceData, usage);
          gl.enarayr(colorAttrib);
          gl.verterb(
            colorAttrib,
            4,
            UNSIGNED_BYTE,
            true,
            BYTES_PER_INSTANCE,
            0,
          );
          gl.vertexAttribDivisor(colorAttrib, 1);
          this.matrices = new Array(maxInstances);
          for (let i = 0; i < maxInstances; i++) {
            const byteOffsetToMatrix =
              1 * BYTES_PER_COMPONENT + i * BYTES_PER_INSTANCE;
            this.matrices[i] = new Float32Array(
              this.instanceData.buffer,
              byteOffsetToMatrix,
              COMPONENTS_PER_MATRIX,
            );
          }
          gl.enarayr(worldMatrixAttrib);
          for (let i = 0; i < 4; i++) {
            const loc = worldMatrixAttrib + i;
            gl.enarayr(loc);
            const offset = 4 + i * 16;
            gl.verterb(loc, 4, FLOAT, false, BYTES_PER_INSTANCE, offset);
            gl.vertexAttribDivisor(loc, 1);
          }
        }
        resetBuffers() {
          this.instanceCount = 0;
        }
        addInstance(color) {
          const i = this.instanceCount++;
          if (DEBUG)
            if (i * COMPONENTS_PER_INSTANCE >= this.instanceData.length)
              throw new Error(
                "Out of instances " +
                  "(i=" +
                  i +
                  ", max=" +
                  this.instanceData.length / COMPONENTS_PER_INSTANCE +
                  ")",
              );
          this.instanceData[i * COMPONENTS_PER_INSTANCE] = color;
          return mat4.identity(this.matrices[i]);
        }
        updateBuffers() {
          gl.binfern(ARRAY_BUFFER, this.instanceBuffer);
          gl.bufataf(ARRAY_BUFFER, this.instanceData, this.usage);
        }
        render() {
          gl.binrayt(this.vao);
          if (this.usage === DYNAMIC_DRAW) {
            gl.binfern(ARRAY_BUFFER, this.instanceBuffer);
            gl.bufferSubData(
              ARRAY_BUFFER,
              0,
              this.instanceData,
              0,
              this.instanceCount * COMPONENTS_PER_INSTANCE,
            );
          }
          gl.drawArraysInstanced(
            TRIANGLES,
            0,
            this.verticesPerInstance,
            this.instanceCount,
          );
        }
      }
      const killEvent = (e) => {
        e.preventDefault();
        e.stopPropagation();
      };
      const KEYBOARD_ENABLED = true;
      const KEY_COUNT = 256;
      const KEY_ENTER = 13;
      const KEY_SHIFT = 16;
      const KEY_ESCAPE = 27;
      const KEY_SPACE = 32;
      const KEY_LEFT = 37;
      const KEY_UP = 38;
      const KEY_RIGHT = 39;
      const KEY_DOWN = 40;
      const KEY_1 = 49;
      const KEY_2 = 50;
      const KEY_3 = 51;
      const KEY_4 = 52;
      const KEY_5 = 53;
      const KEY_6 = 54;
      const KEY_7 = 55;
      const KEY_8 = 56;
      const KEY_9 = 57;
      const KEY_A = 65;
      const KEY_D = 68;
      const KEY_M = 77;
      const KEY_Q = 81;
      const KEY_R = 82;
      const KEY_S = 83;
      const KEY_W = 87;
      const KEY_X = 88;
      const KEY_Z = 90;
      let Key;
      const keys = new Array(256)
        .fill(undefined)
        .map(() => ({ down: false, downCount: 0, upCount: 1 }));
      const anyKey = { down: false, downCount: 0, upCount: 1 };
      const updateKeys = () => {
        anyKey.down = false;
        keys.forEach((k) => {
          if (k.down) {
            anyKey.down = true;
            k.upCount = 0;
            k.downCount++;
          } else {
            k.upCount++;
            k.downCount = 0;
          }
        });
        if (anyKey.down) {
          anyKey.upCount = 0;
          anyKey.downCount++;
        } else {
          anyKey.upCount++;
          anyKey.downCount = 0;
        }
      };
      const resetKeys = () => {
        anyKey.down = false;
        keys.forEach((k) => (k.down = false));
        updateKeys();
      };
      const isKeyDown = (keyCode) => KEYBOARD_ENABLED && keys[keyCode].down;
      const isKeyPressed = (keyCode) =>
        KEYBOARD_ENABLED && keys[keyCode].upCount === 1;
      document.addEventListener("keydown", (e) => {
        keys[e.keyCode].down = true;
      });
      document.addEventListener("keyup", (e) => {
        keys[e.keyCode].down = false;
      });
      window.addEventListener("blur", resetKeys);
      const ZERO = 0;
      const ONE = 1;
      const DEPTH_BUFFER_BIT = 256;
      const COLOR_BUFFER_BIT = 16384;
      const TRIANGLES = 4;
      const LEQUAL = 515;
      const SRC_ALPHA = 770;
      const ONE_MINUS_SRC_ALPHA = 771;
      const CULL_FACE = 2884;
      const DEPTH_TEST = 2929;
      const BLEND = 3042;
      const TEXTURE_2D = 3553;
      const UNSIGNED_BYTE = 5121;
      const UNSIGNED_SHORT = 5123;
      const FLOAT = 5126;
      const DEPTH_COMPONENT = 6402;
      const RGBA = 6408;
      const NEAREST = 9728;
      const LINEAR = 9729;
      const TEXTURE_MAG_FILTER = 10240;
      const TEXTURE_MIN_FILTER = 10241;
      const TEXTURE_WRAP_S = 10242;
      const TEXTURE_WRAP_T = 10243;
      const CLAMP_TO_EDGE = 33071;
      const DEPTH_COMPONENT16 = 33189;
      const TEXTURE0 = 33984;
      const TEXTURE1 = 33985;
      const TEXTURE2 = 33986;
      const ARRAY_BUFFER = 34962;
      const ELEMENT_ARRAY_BUFFER = 34963;
      const STATIC_DRAW = 35044;
      const DYNAMIC_DRAW = 35048;
      const FRAGMENT_SHADER = 35632;
      const VERTEX_SHADER = 35633;
      const COMPILE_STATUS = 35713;
      const LINK_STATUS = 35714;
      const DEPTH_COMPONENT32F = 36012;
      const COLOR_ATTACHMENT0 = 36064;
      const DEPTH_ATTACHMENT = 36096;
      const FRAMEBUFFER = 36160;
      const RENDERBUFFER = 36161;
      const EPSILON = 1e-5;
      const OVERLAY_WHITE = "#f0f0f0";
      const OVERLAY_BLACK = "#000";
      const OVERLAY_LIGHT_GRAY = "#aaa";
      const OVERLAY_DARK_GRAY = "#444";
      const OVERLAY_YELLOW = "#fffe37";
      const OVERLAY_DARK_YELLOW = "#881";
      const OVERLAY_GREEN = "#0c0";
      const OVERLAY_DARK_GREEN = "#080";
      const OVERLAY_ORANGE = "#fe9400";
      const ALIGN_LEFT = "left";
      const ALIGN_CENTER = "center";
      const ALIGN_RIGHT = "right";
      let IS_FULLSCREEN = false;
      let OS = "";

      (async () => {
        const webview = await ext.webviews.getCurrent();
        const window = await ext.webviews.getAttachedWindow(webview.id);
        IS_FULLSCREEN = await ext.windows.isFullscreen(window.id);
      })();

      ext.windows.onEnteredFullscreen.addListener(() => {
        IS_FULLSCREEN = true;
      });
      ext.windows.onExitedFullscreen.addListener(() => {
        IS_FULLSCREEN = false;
      });

      function drawText(str, x, y, fillColor = OVERLAY_BLACK) {
        overlayCtx.fillStyle = fillColor;
        overlayCtx.fillText(str, x, y);
      }
      function drawShadowText(str, x, y, fillColor = OVERLAY_WHITE) {
        drawText(str, x + 2, y + 2);
        drawText(str, x, y, fillColor);
      }
      function setFontSize(size, style = "") {
        overlayCtx.font = `bold ${style} ${size}px Comic Sans MS`;
      }
      function setTextAlign(align) {
        overlayCtx.textAlign = align;
      }
      function drawKeyIcon(str, x, y, width = 36) {
        drawRectangle(
          x - width / 2,
          y - 8,
          width,
          36,
          "rgba(0,0,0,0.5)",
          OVERLAY_WHITE,
        );
        drawShadowText(str, x, y);
      }
      function drawRectangle(x, y, width, height, fillStyle, strokeStyle) {
        overlayCtx.fillStyle = fillStyle;
        overlayCtx.fillRect(x, y, width, height);
        overlayCtx.strokeStyle = strokeStyle;
        overlayCtx.lineWidth = 3;
        overlayCtx.strokeRect(x, y, width, height);
      }
      let FBO;
      const createFbo = (size) => {
        const colorTexture = gl.createTexture();
        gl.binured(TEXTURE_2D, colorTexture);
        const level = 0;
        {
          const internalFormat = RGBA;
          const border = 0;
          const format = RGBA;
          const type = UNSIGNED_BYTE;
          const data = null;
          gl.texImage2D(
            TEXTURE_2D,
            level,
            internalFormat,
            size,
            size,
            border,
            format,
            type,
            data,
          );
          gl.texerir(TEXTURE_2D, TEXTURE_MIN_FILTER, LINEAR);
          gl.texerir(TEXTURE_2D, TEXTURE_WRAP_S, CLAMP_TO_EDGE);
          gl.texerir(TEXTURE_2D, TEXTURE_WRAP_T, CLAMP_TO_EDGE);
        }
        const depthTexture = gl.createTexture();
        gl.binured(gl.TEXTURE_2D, depthTexture);
        gl.texImage2D(
          TEXTURE_2D,
          0,
          DEPTH_COMPONENT32F,
          size,
          size,
          0,
          DEPTH_COMPONENT,
          FLOAT,
          null,
        );
        gl.texerir(TEXTURE_2D, TEXTURE_MAG_FILTER, NEAREST);
        gl.texerir(TEXTURE_2D, TEXTURE_MIN_FILTER, NEAREST);
        gl.texerir(TEXTURE_2D, TEXTURE_WRAP_S, CLAMP_TO_EDGE);
        gl.texerir(TEXTURE_2D, TEXTURE_WRAP_T, CLAMP_TO_EDGE);
        const framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(FRAMEBUFFER, framebuffer);
        gl.framebufferTexture2D(
          FRAMEBUFFER,
          COLOR_ATTACHMENT0,
          TEXTURE_2D,
          colorTexture,
          0,
        );
        gl.framebufferTexture2D(
          FRAMEBUFFER,
          DEPTH_ATTACHMENT,
          TEXTURE_2D,
          depthTexture,
          0,
        );
        return {
          size: size,
          colorTexture: colorTexture,
          depthTexture: depthTexture,
          frameBuffer: framebuffer,
        };
      };
      const bindFbo = (fbo) => {
        gl.bindFramebuffer(FRAMEBUFFER, fbo.frameBuffer);
        gl.viewport(0, 0, fbo.size, fbo.size);
      };
      const bindScreen = () => {
        gl.bindFramebuffer(FRAMEBUFFER, null);
        gl.viewport(0, 0, WIDTH, HEIGHT);
      };
      let Camera;
      const createCamera = () => ({
        source: vec3.create(),
        pitch: 0,
        yaw: 0,
        fov: 0,
        distance: 0,
      });
      const setCamera = (camera, x, y, z, pitch, yaw, fov) => {
        vec3.set(camera.source, x, y, z);
        camera.pitch = pitch;
        camera.yaw = yaw;
        camera.fov = fov;
      };
      const lookAt = (camera, source, target, fov) => {
        vec3.copy(camera.source, source);
        vec3.subtract(tempVec, target, source);
        camera.distance = vec3.magnitude(tempVec);
        camera.yaw = Math.atan2(tempVec[0], tempVec[2]);
        camera.pitch = Math.atan2(
          tempVec[1],
          Math.hypot(tempVec[0], tempVec[2]),
        );
        camera.fov = fov;
      };
      const ATTRIBUTE_COLOR = "a";
      const ATTRIBUTE_POSITION = "b";
      const ATTRIBUTE_TEXCOORD = "c";
      const ATTRIBUTE_WORLDMATRIX = "d";
      const UNIFORM_BLOOMTEXTURE = "f";
      const UNIFORM_COLORTEXTURE = "g";
      const UNIFORM_DEPTHTEXTURE = "h";
      const UNIFORM_ITERATION = "i";
      const UNIFORM_LIGHTCOLORS = "j";
      const UNIFORM_LIGHTPOSITIONS = "k";
      const UNIFORM_PROJECTIONMATRIX = "l";
      const UNIFORM_SHADOWMAPMATRIX = "m";
      const UNIFORM_VIEWMATRIX = "n";
      const GLSL_PREFIX = "#version 300 es\n" + "precision highp float;";
      const BLOOM_FRAG =
        GLSL_PREFIX +
        "uniform sampler2D g;" +
        "uniform int i;" +
        "in vec2 s;" +
        "out vec4 e;" +
        "float w=0.99;" +
        "float x[11]=float[11](0.01,0.02,0.04,0.08,0.16,0.38,0.16,0.08,0.04,0.02,0.01);" +
        "void main(){" +
        "if(i==0){" +
        "vec4 t=texture(g,s);" +
        "if(t.r>w||t.g>w||t.b>w){" +
        "e=t;" +
        "}" +
        "else{" +
        "discard;" +
        "}" +
        "}" +
        "else if(i==1||i==3){" +
        "vec4 u=vec4(0);" +
        "float v=0.0;" +
        "for(int xi=-5;" +
        "xi<=5;" +
        "xi++){" +
        "vec4 t=texture(g,s+vec2(float(xi)/512.0,0.0));" +
        "u.rgb+=x[xi+5]*t.rgb*t.a;" +
        "v+=x[xi+5]*t.a;" +
        "}" +
        "if(v==0.0){" +
        "e=vec4(0,0,0,1);" +
        "}" +
        "else{" +
        "u.rgb/=v;" +
        "u.a=v;" +
        "e=u;" +
        "}" +
        "}" +
        "else{" +
        "vec4 u=vec4(0);" +
        "float v=0.0;" +
        "for(int yi=-5;" +
        "yi<=5;" +
        "yi++){" +
        "vec4 t=texture(g,s+vec2(0.0,float(yi)/512.0));" +
        "u.rgb+=x[yi+5]*t.rgb*t.a;" +
        "v+=x[yi+5]*t.a;" +
        "}" +
        "if(v==0.0){" +
        "e=vec4(0,0,0,1);" +
        "}" +
        "else{" +
        "u.rgb/=v;" +
        "u.a=v;" +
        "e=u;" +
        "}" +
        "}" +
        "}";
      const BLOOM_VERT =
        GLSL_PREFIX +
        "in vec2 b;" +
        "in vec2 c;" +
        "out vec2 s;" +
        "void main(){" +
        "gl_Position=vec4(b,0,1);" +
        "s=c;" +
        "}";
      const MAIN_FRAG =
        GLSL_PREFIX +
        "uniform sampler2D g;" +
        "uniform sampler2D h;" +
        "uniform vec3 k[16];" +
        "uniform vec3 j[16];" +
        "in vec4 o;" +
        "in float p;" +
        "in vec4 q;" +
        "in vec4 r;" +
        "out vec4 e;" +
        "void main(){" +
        "if(o.r>0.99||o.g>0.99||o.b>0.99){" +
        "e=o;" +
        "return;" +
        "}" +
        "if(o.r<0.1&&o.g<0.1&&o.b<0.1){" +
        "vec3 v=normalize(normalize((-q).xyz)-.5);" +
        "float w,cody_a=w=0.;" +
        "for(int cody_i=0;" +
        "cody_i<15;" +
        "cody_i+=1){" +
        "v=abs(v)/dot(v,v)-.49;" +
        "cody_a+=abs(length(v)-w);" +
        "w=length(v);" +
        "}" +
        "cody_a*=cody_a*cody_a;" +
        "e.rgb=.5*clamp((pow(vec3(cody_a/2e5,cody_a/2e5,cody_a/1e5),vec3(.9))),0.,2.)+vec3(0.03,0.0,0.12);" +
        "e.a=1.0;" +
        "return;" +
        "}" +
        "vec3 S=normalize(cross(dFdx(q.xyz),dFdy(q.xyz)));" +
        "vec3 E=vec3(-.25,-.75,.2);" +
        "vec3 N=E-2.0*dot(E,S)*S;" +
        "vec3 t=normalize(vec3(0,0,1));" +
        "float P=20.0;" +
        "vec3 K=r.xyz/r.w;" +
        "float H=0.0;" +
        "float u=0.0;" +
        "for(float M=-3.0;" +
        "M<=3.0;" +
        "M+=1.0){" +
        "for(float L=-3.0;" +
        "L<=3.0;" +
        "L+=1.0){" +
        "if(((texture(h,K.xy+vec2(L,M)/2048.0)).r)<=(K.z*0.99999965)){" +
        "u+=1.0;" +
        "}" +
        "H+=1.0;" +
        "}" +
        "}" +
        "float O=(K.x>=0.0&&K.x<=1.0&&K.y>=0.0&&K.y<=1.0)?1.0-0.5*u/H:1.0;" +
        "vec3 R=mix(vec3(0.0,0.1,0.4),o.rgb,(clamp((0.5+0.5*(max(dot(S,E),0.0))*O)+O*(0.0),0.0,1.0)));" +
        "for(int light=0;" +
        "light<16;" +
        "light++){" +
        "vec3 G=q.xyz-k[light];" +
        "float C=length(G);" +
        "R.rgb+=0.2*max(0.0,dot(normalize(G),S))*(clamp((2.0)/(C*C),0.0,1.0))*j[light];" +
        "}" +
        "e.rgb=R.rgb;" +
        "e.a=1.0;" +
        "}";
      const MAIN_VERT =
        GLSL_PREFIX +
        "in vec4 b;" +
        "in vec4 a;" +
        "in mat4 d;" +
        "uniform mat4 l;" +
        "uniform mat4 n;" +
        "uniform mat4 m;" +
        "out vec4 q;" +
        "out vec4 o;" +
        "out float p;" +
        "out vec4 r;" +
        "void main(){" +
        "q=d*b;" +
        "o=a;" +
        "p=-(n*q).z;" +
        "r=m*q;" +
        "gl_Position=l*n*q;" +
        "}";
      const POST_FRAG =
        GLSL_PREFIX +
        "uniform sampler2D g;" +
        "uniform sampler2D f;" +
        "in vec2 s;" +
        "out vec4 e;" +
        "void main(){" +
        "vec4 t=texture(f,s);" +
        "e=vec4((texture(g,s)).rgb+2.0*t.a*t.rgb,1);" +
        "}";
      const POST_VERT =
        GLSL_PREFIX +
        "in vec2 b;" +
        "in vec2 c;" +
        "out vec2 s;" +
        "void main(){" +
        "gl_Position=vec4(b,0,1);" +
        "s=c;" +
        "}";
      const SHADOW_FRAG =
        GLSL_PREFIX + "out vec4 e;" + "void main(){" + "e=vec4(1,1,1,1);" + "}";
      const SHADOW_VERT =
        GLSL_PREFIX +
        "in vec4 b;" +
        "in mat4 d;" +
        "uniform mat4 l;" +
        "uniform mat4 n;" +
        "void main(){" +
        "gl_Position=l*n*d*b;" +
        "}";
      function initShaderProgram(
        vertexShaderSource,
        fragmentShaderSource,
        bindAttribs,
      ) {
        const vertexShader = loadShader(VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = loadShader(
          FRAGMENT_SHADER,
          fragmentShaderSource,
        );
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        if (bindAttribs) {
          gl.bindAttribLocation(program, positionAttrib, ATTRIBUTE_POSITION);
          gl.bindAttribLocation(program, colorAttrib, ATTRIBUTE_COLOR);
          gl.bindAttribLocation(
            program,
            worldMatrixAttrib,
            ATTRIBUTE_WORLDMATRIX,
          );
        }
        gl.linkProgram(program);
        if (DEBUG) {
          const compiled = gl.getProgramParameter(program, LINK_STATUS);
          log("Program compiled: " + compiled);
          const compilationLog = gl.getProgramInfoLog(program);
          log("Program compiler log: " + compilationLog);
        }
        return program;
      }
      function loadShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (DEBUG) {
          const compiled = gl.getShaderParameter(shader, COMPILE_STATUS);
          log("Shader compiled: " + compiled);
          const compilationLog = gl.getShaderInfoLog(shader);
          log("Shader compiler log: " + compilationLog);
        }
        return shader;
      }
      function getUniform(program, name) {
        return gl.getUniformLocation(program, name);
      }
      function resetGl() {
        gl.clearColor(0, 0, 0, 1);
        gl.clearDepth(1);
        gl.enable(DEPTH_TEST);
        gl.depthFunc(LEQUAL);
        gl.enable(BLEND);
        gl.blendFunc(SRC_ALPHA, ONE_MINUS_SRC_ALPHA);
        gl.clear(COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT);
      }
      function setupCamera(camera, w, h) {
        const aspect = w / h;
        const zNear = 0.1;
        const zFar = 1e3;
        mat4.perspective(projectionMatrix, camera.fov, aspect, zNear, zFar);
        mat4.rotateX(pitchMatrix, mat4.identity(pitchMatrix), camera.pitch);
        mat4.rotateY(yawMatrix, mat4.identity(yawMatrix), -camera.yaw);
        mat4.multiply(modelViewMatrix, pitchMatrix, yawMatrix);
        vec3.subtract(cameraTranslate, origin, camera.source);
        mat4.translate(modelViewMatrix, modelViewMatrix, cameraTranslate);
      }
      const WIDTH = 1920;
      const HEIGHT = 1080;
      const CENTER_X = WIDTH / 2;
      const CENTER_Y = HEIGHT / 2;
      const MAIN_FBO_SIZE = 2048;
      const BLOOM_FBO_SIZE = 512;
      const canvases = document.querySelectorAll("canvas");
      const canvas = canvases[0];
      const overlayCanvas = canvases[1];
      const overlayCtx = overlayCanvas.getContext("2d");
      const origin = vec3.create();
      const forward = vec3.fromValues(0, 0, 1);
      const tempVec = vec3.create();
      const camera = createCamera();
      const lightSource = createCamera();
      const cameraTranslate = vec3.create();
      const projectionMatrix = mat4.create();
      const modelViewMatrix = mat4.create();
      const pitchMatrix = mat4.create();
      const yawMatrix = mat4.create();
      const identity = mat4.create();
      const shadowMapMatrix = mat4.create();
      const positionAttrib = 0;
      const colorAttrib = 1;
      const worldMatrixAttrib = 2;
      const gl = canvas.getContext("webgl2", { alpha: false });
      buildShortcuts(gl);
      const shadowProgram = initShaderProgram(SHADOW_VERT, SHADOW_FRAG, true);
      const viewMatrixUniform1 = getUniform(shadowProgram, UNIFORM_VIEWMATRIX);
      const projectionMatrixUniform1 = getUniform(
        shadowProgram,
        UNIFORM_PROJECTIONMATRIX,
      );
      const mainProgram = initShaderProgram(MAIN_VERT, MAIN_FRAG, true);
      const viewMatrixUniform2 = getUniform(mainProgram, UNIFORM_VIEWMATRIX);
      const projectionMatrixUniform2 = getUniform(
        mainProgram,
        UNIFORM_PROJECTIONMATRIX,
      );
      const colorTextureSamplerUniform = getUniform(
        mainProgram,
        UNIFORM_COLORTEXTURE,
      );
      const shadowMapMatrixUniform = getUniform(
        mainProgram,
        UNIFORM_SHADOWMAPMATRIX,
      );
      const depthTextureSamplerUniform = getUniform(
        mainProgram,
        UNIFORM_DEPTHTEXTURE,
      );
      const lightColorsUniform = getUniform(mainProgram, UNIFORM_LIGHTCOLORS);
      const lightPositionsUniform = getUniform(
        mainProgram,
        UNIFORM_LIGHTPOSITIONS,
      );
      const lightColors = new Float32Array(3 * 16);
      const lightPositions = new Float32Array(3 * 16);
      let nextLight = 0;
      const buffers = [];
      const shadowFbo = createFbo(MAIN_FBO_SIZE);
      const mainFbo = createFbo(MAIN_FBO_SIZE);
      const pingPongFbo1 = createFbo(BLOOM_FBO_SIZE);
      const pingPongFbo2 = createFbo(BLOOM_FBO_SIZE);
      const bloomProgram = initShaderProgram(BLOOM_VERT, BLOOM_FRAG);
      const bloomPositionAttrib = gl.getAttribLocation(
        bloomProgram,
        ATTRIBUTE_POSITION,
      );
      const bloomTexCoordAttrib = gl.getAttribLocation(
        bloomProgram,
        ATTRIBUTE_TEXCOORD,
      );
      const bloomColorTextureUniform = getUniform(
        bloomProgram,
        UNIFORM_COLORTEXTURE,
      );
      const bloomIterationUniform = getUniform(bloomProgram, UNIFORM_ITERATION);
      const depthOfFieldProgram = initShaderProgram(POST_VERT, POST_FRAG);
      const depthOfFieldPositionAttrib = gl.getAttribLocation(
        depthOfFieldProgram,
        ATTRIBUTE_POSITION,
      );
      const depthOfFieldTexCoordAttrib = gl.getAttribLocation(
        depthOfFieldProgram,
        ATTRIBUTE_TEXCOORD,
      );
      const depthOfFieldColorTextureUniform = getUniform(
        depthOfFieldProgram,
        UNIFORM_COLORTEXTURE,
      );
      const depthOfFieldDepthTextureUniform = getUniform(
        depthOfFieldProgram,
        UNIFORM_DEPTHTEXTURE,
      );
      const depthOfFieldBloomTextureUniform = getUniform(
        depthOfFieldProgram,
        UNIFORM_BLOOMTEXTURE,
      );
      const depthOfFieldVao = gl.createVertexArray();
      gl.binrayt(depthOfFieldVao);
      const depthOfFieldPositionBuffer = gl.createBuffer();
      gl.binfern(ARRAY_BUFFER, depthOfFieldPositionBuffer);
      gl.bufataf(
        ARRAY_BUFFER,
        new Float32Array([-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1]),
        STATIC_DRAW,
      );
      gl.enarayr(depthOfFieldPositionAttrib);
      gl.verterb(depthOfFieldPositionAttrib, 2, FLOAT, false, 0, 0);
      const depthOfFieldTextureBuffer = gl.createBuffer();
      gl.binfern(ARRAY_BUFFER, depthOfFieldTextureBuffer);
      gl.bufataf(
        ARRAY_BUFFER,
        new Float32Array([0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1]),
        STATIC_DRAW,
      );
      gl.enarayr(depthOfFieldTexCoordAttrib);
      gl.verterb(depthOfFieldTexCoordAttrib, 2, FLOAT, false, 0, 0);
      let time = 0;
      let gameTime = 0;
      let dt = 0;
      let drawCount = 0;
      let triangleCount = 0;
      let lastRenderTime = 0;
      let fps = 0;
      let averageFps = 0;
      const pixelString = (num) => Math.floor(num) + "px";
      window.addEventListener("resize", handleResizeEvent, false);
      handleResizeEvent();
      function handleResizeEvent() {
        const scale = Math.min(
          window.innerWidth / WIDTH,
          window.innerHeight / HEIGHT,
        );
        const width = scale * WIDTH;
        const height = scale * HEIGHT;
        const x = (window.innerWidth - width) / 2;
        const y = (window.innerHeight - height) / 2;
        if (canvas) {
          canvas.width = WIDTH;
          canvas.height = HEIGHT;
          canvas.style.left = pixelString(x);
          canvas.style.top = pixelString(y);
          canvas.style.width = pixelString(width);
          canvas.style.height = pixelString(height);
        }
        if (overlayCanvas) {
          overlayCanvas.width = WIDTH;
          overlayCanvas.height = HEIGHT;
          overlayCanvas.style.left = pixelString(x);
          overlayCanvas.style.top = pixelString(y);
          overlayCanvas.style.width = pixelString(width);
          overlayCanvas.style.height = pixelString(height);
        }
      }
      function render(now) {
        if (DEBUG) {
          drawCount = 0;
          triangleCount = 0;
          if (lastRenderTime === 0) lastRenderTime = now;
          else {
            const actualDelta = now - lastRenderTime;
            lastRenderTime = now;
            fps = 1e3 / actualDelta;
            averageFps = 0.9 * averageFps + 0.1 * fps;
          }
        }
        now *= 0.001;
        dt = Math.min(now - time, 1 / 30);
        time = now;
        if (gameState === GameState.PLAYING && !menu) gameTime += dt;
        updateKeys();
        overlayCtx.clearRect(0, 0, WIDTH, HEIGHT);
        overlayCtx.textBaseline = "top";
        buffers.forEach((b) => b.usage === DYNAMIC_DRAW && b.resetBuffers());
        update();
        buffers.forEach((b) => b.usage === DYNAMIC_DRAW && b.updateBuffers());
        bindFbo(shadowFbo);
        resetGl();
        setupCamera(lightSource, shadowFbo.size, shadowFbo.size);
        gl.useProgram(shadowProgram);
        gl.uni4fva(projectionMatrixUniform1, false, projectionMatrix);
        gl.uni4fva(viewMatrixUniform1, false, modelViewMatrix);
        renderScene();
        mat4.identity(shadowMapMatrix);
        mat4.translate(
          shadowMapMatrix,
          shadowMapMatrix,
          vec3.fromValues(0.5, 0.5, 0.5),
        );
        mat4.scale(
          shadowMapMatrix,
          shadowMapMatrix,
          vec3.fromValues(0.5, 0.5, 0.5),
        );
        mat4.multiply(shadowMapMatrix, shadowMapMatrix, projectionMatrix);
        mat4.multiply(shadowMapMatrix, shadowMapMatrix, modelViewMatrix);
        bindFbo(mainFbo);
        resetGl();
        setupCamera(camera, WIDTH, HEIGHT);
        gl.useProgram(mainProgram);
        gl.uni4fva(projectionMatrixUniform2, false, projectionMatrix);
        gl.uni4fva(viewMatrixUniform2, false, modelViewMatrix);
        gl.uni4fva(shadowMapMatrixUniform, false, shadowMapMatrix);
        gl.uniform3fv(lightColorsUniform, lightColors);
        gl.uniform3fv(lightPositionsUniform, lightPositions);
        gl.acturee(TEXTURE0);
        gl.binured(TEXTURE_2D, shadowFbo.depthTexture);
        gl.uniform1i(depthTextureSamplerUniform, 0);
        renderScene();
        let inputFbo = mainFbo;
        let outputFbo = pingPongFbo1;
        gl.useProgram(bloomProgram);
        for (let i = 0; i < 5; i++) {
          bindFbo(outputFbo);
          resetGl();
          gl.binrayt(depthOfFieldVao);
          gl.acturee(TEXTURE0);
          gl.binured(TEXTURE_2D, inputFbo.colorTexture);
          gl.uniform1i(bloomColorTextureUniform, 0);
          gl.uniform1i(bloomIterationUniform, i);
          gl.drawArrays(TRIANGLES, 0, 6);
          if (i % 2 === 0) {
            inputFbo = pingPongFbo1;
            outputFbo = pingPongFbo2;
          } else {
            inputFbo = pingPongFbo2;
            outputFbo = pingPongFbo1;
          }
        }
        bindScreen();
        gl.useProgram(depthOfFieldProgram);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT);
        gl.binrayt(depthOfFieldVao);
        gl.acturee(TEXTURE0);
        gl.binured(TEXTURE_2D, mainFbo.colorTexture);
        gl.uniform1i(depthOfFieldColorTextureUniform, 0);
        gl.acturee(TEXTURE1);
        gl.binured(TEXTURE_2D, mainFbo.depthTexture);
        gl.uniform1i(depthOfFieldDepthTextureUniform, 1);
        gl.acturee(TEXTURE2);
        gl.binured(TEXTURE_2D, pingPongFbo1.colorTexture);
        gl.uniform1i(depthOfFieldBloomTextureUniform, 2);
        gl.drawArrays(TRIANGLES, 0, 6);
        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);
      function renderScene() {
        buffers.forEach((b) => b.render());
      }
      function resetLights() {
        lightColors.fill(0);
        lightPositions.fill(0);
        nextLight = 0;
      }
      function addLight(position, color) {
        lightColors[nextLight * 3] = color[0];
        lightColors[nextLight * 3 + 1] = color[1];
        lightColors[nextLight * 3 + 2] = color[2];
        lightPositions[nextLight * 3] = position[0];
        lightPositions[nextLight * 3 + 1] = position[1];
        lightPositions[nextLight * 3 + 2] = position[2];
        nextLight++;
      }
      class GameEntity {
        constructor(x, y, z) {
          this.pos = vec3.fromValues(x || 0, y || 0, z || 0);
          this.velocity = vec3.create();
          this.transformMatrix = mat4.create();
          this.health = 100;
          this.yaw = 0;
          this.accelerating = false;
          this.groundedTime = 0;
          this.groundedPlatform = null;
          this.shootTime = 0;
          this.bounciness = 0;
          this.waypoints = [];
          this.waypointIndex = 0;
          this.rendered = true;
        }
        isGrounded() {
          return this.groundedTime === gameTime;
        }
        canShoot() {
          return gameTime - this.shootTime > 0.5;
        }
        jump() {
          this.velocity[1] = JUMP_POWER;
          this.groundedTime = 0;
          this.groundedPlatform = null;
          if (this === player) playJumpSound();
        }
        update() {}
        render() {}
        getDistanceToPlayer() {
          if (player.health <= 0) return 1e3;
          return vec3.distance(player.pos, this.pos);
        }
        updateWaypoints() {
          if (this.waypoints.length === 0) return null;
          const waypoint = this.waypoints[this.waypointIndex];
          if (vec3.distance(this.pos, waypoint) < 0.1)
            this.waypointIndex =
              (this.waypointIndex + 1) % this.waypoints.length;
          return waypoint;
        }
        setupTransformMatrix() {
          const theta = time * 20;
          const speed = Math.hypot(this.velocity[0], this.velocity[2]);
          const bodyOffsetY = this.bounciness * Math.sin(theta) * speed;
          const bodyRotationX = 0.02 * speed;
          vec3.copy(tempVec, this.pos);
          if (this.isGrounded()) tempVec[1] += bodyOffsetY;
          mat4.identity(this.transformMatrix);
          mat4.translate(this.transformMatrix, this.transformMatrix, tempVec);
          mat4.rotateY(this.transformMatrix, this.transformMatrix, this.yaw);
          mat4.rotateX(
            this.transformMatrix,
            this.transformMatrix,
            bodyRotationX,
          );
        }
        createSphere(color) {
          const m = buffers[DYNAMIC_SPHERES].addInstance(color);
          mat4.multiply(m, m, this.transformMatrix);
          return m;
        }
      }
      class Alien extends GameEntity {
        constructor(x, y, z) {
          super(x, y, z);
          this.acceleration = 60;
          this.aggroRange = 15;
          this.color = COLOR_ALIEN_GREEN;
          this.bounciness = 0.01;
        }
        update() {
          const waypoint = this.updateWaypoints();
          const dist = this.getDistanceToPlayer();
          if (dist < 1.5)
            if (player.pos[1] > this.pos[1]) {
              this.health = 0;
              player.pos[1] = this.pos[1] + 2;
              player.jump();
              createExplosion(this.pos, this.color, 15);
            } else {
              player.health = 0;
              player.rendered = false;
              playerDie();
              createExplosion(player.pos, this.color);
            }
          else if (dist < this.aggroRange) {
            vec3.subtract(tempVec, player.pos, this.pos);
            tempVec[1] = 0;
            vec3.normalize(tempVec, tempVec);
            vec3.scaleAndAdd(
              this.velocity,
              this.velocity,
              tempVec,
              dt * this.acceleration,
            );
          } else if (waypoint) {
            vec3.subtract(tempVec, waypoint, this.pos);
            vec3.normalize(tempVec, tempVec);
            vec3.scaleAndAdd(
              this.velocity,
              this.velocity,
              tempVec,
              dt * this.acceleration,
            );
          }
          updateEntity(this);
        }
        render() {
          {
            const m = this.createSphere(this.color);
            mat4.translate(m, m, vec3.fromValues(0, 0.8, 0));
            mat4.scale(m, m, vec3.fromValues(0.8, 0.8, 0.7));
          }
          {
            const m = this.createSphere(COLOR_BLACK);
            mat4.translate(m, m, vec3.fromValues(-0.25, 0.9, 0.7));
            mat4.rotateZ(m, m, -1);
            mat4.scale(m, m, vec3.fromValues(0.2, 0.1, 0.025));
          }
          {
            const m = this.createSphere(COLOR_BLACK);
            mat4.translate(m, m, vec3.fromValues(0.25, 0.9, 0.7));
            mat4.rotateZ(m, m, 1);
            mat4.scale(m, m, vec3.fromValues(0.2, 0.1, 0.025));
          }
        }
      }
      class Coin extends GameEntity {
        update() {
          const dist = this.getDistanceToPlayer();
          if (dist < 1) {
            this.health = 0;
            coins++;
            coinSequence++;
            lastCoinTime = gameTime;
            playCoinSound();
          } else if (dist < 3) {
            this.pos[0] = 0.9 * this.pos[0] + 0.1 * player.pos[0];
            this.pos[1] = 0.9 * this.pos[1] + 0.1 * player.pos[1];
            this.pos[2] = 0.9 * this.pos[2] + 0.1 * player.pos[2];
          }
        }
        render() {
          const r = (time % 1) * 2 * Math.PI;
          const y = 1.5 + 0.2 * Math.sin(r);
          const m = this.createSphere(COLOR_YELLOW);
          mat4.translate(m, m, vec3.fromValues(0, y, 0));
          mat4.rotateY(m, m, r);
          mat4.scale(m, m, vec3.fromValues(0.5, 0.5, 0.1));
        }
      }
      class Flagpole extends GameEntity {
        constructor(x, y, z) {
          super(x, y, z);
          this.triggered = false;
        }
        update() {
          const dist = this.getDistanceToPlayer();
          if (coins === availableCoins && dist < 2 && !this.triggered) {
            playMusic(flagpoleSongData);
            bestTimes[level] = bestTimes[level]
              ? Math.min(bestTimes[level], gameTime)
              : gameTime;
            localStorage["callisto-times"] = JSON.stringify(bestTimes);
            addTrophy(`Level ${level}`, `${gameTime.toFixed(1)} sec`);
            stopJetpackSound();
            setMenu(winScreen);
            gameState = GameState.AFTER_LEVEL;
            this.triggered = true;
          }
        }
        render() {
          const r = (time % 1) * 2 * Math.PI;
          const y = 4.7 + 0.1 * Math.sin(r);
          {
            const m = this.createSphere(COLOR_SILVER);
            mat4.translate(m, m, vec3.fromValues(0, 2.5, 0));
            mat4.scale(m, m, vec3.fromValues(0.2, 2.5, 0.2));
          }
          {
            const m = this.createSphere(COLOR_SILVER);
            mat4.scale(m, m, vec3.fromValues(0.5, 0.5, 0.5));
          }
          {
            const m = this.createSphere(COLOR_RED);
            mat4.translate(m, m, vec3.fromValues(0, y, 0));
            mat4.rotateY(m, m, r);
            mat4.scale(m, m, vec3.fromValues(0.5, 0.5, 0.5));
          }
        }
      }
      class Fuel extends GameEntity {
        constructor(x, y, z, amount) {
          super(x, y, z);
          this.amount = amount || 30;
        }
        update() {
          const dist = this.getDistanceToPlayer();
          if (dist < 1) {
            player.fuel += this.amount;
            this.health = 0;
            this.amount = 0;
            playFuelSound();
          } else if (dist < 4) {
            this.pos[0] = 0.9 * this.pos[0] + 0.1 * player.pos[0];
            this.pos[1] = 0.9 * this.pos[1] + 0.1 * player.pos[1];
            this.pos[2] = 0.9 * this.pos[2] + 0.1 * player.pos[2];
          }
        }
        render() {
          const r = (time % 1) * 2 * Math.PI;
          const y = 1.5 + 0.2 * Math.sin(r);
          {
            const m = this.createSphere(COLOR_DARK_SILVER);
            mat4.translate(m, m, vec3.fromValues(-0.24, y, 0));
            mat4.rotateY(m, m, r);
            mat4.scale(m, m, vec3.fromValues(0.3, 0.64, 0.3));
          }
          {
            const m = this.createSphere(COLOR_DARK_SILVER);
            mat4.translate(m, m, vec3.fromValues(0.24, y, 0));
            mat4.rotateY(m, m, r);
            mat4.scale(m, m, vec3.fromValues(0.3, 0.64, 0.3));
          }
        }
      }
      class Hero extends GameEntity {
        constructor(x, y, z) {
          super(x, y, z);
          this.bounciness = 0.01;
          this.fuel = 100;
          this.jetpack = false;
        }
        render() {
          let leftArmRotationX = 0;
          let leftArmRotationZ = 1.2;
          let rightArmRotationX = 0;
          let rightArmRotationZ = -1.2;
          let leftLegRotationX = 0;
          let rightLegRotationX = 0;
          if (!this.isGrounded() || gameState === GameState.AFTER_LEVEL) {
            leftArmRotationZ = -0.5;
            rightArmRotationZ = 0.5;
          } else if (this.accelerating) {
            const r = ((gameTime % 0.8) / 0.8) * 2 * Math.PI;
            rightLegRotationX = leftArmRotationX =
              0.07 *
              Math.hypot(this.velocity[0], this.velocity[2]) *
              Math.sin(r);
            rightArmRotationX = leftLegRotationX = -leftArmRotationX;
            leftArmRotationZ = 1.2;
            rightArmRotationZ = -1.2;
          }
          {
            const m = this.createSphere(COLOR_ORANGE);
            mat4.translate(m, m, vec3.fromValues(0, 1.8, 0));
            mat4.scale(m, m, vec3.fromValues(0.38, 0.38, 0.38));
          }
          {
            const m = this.createSphere(COLOR_WHITE);
            mat4.translate(m, m, vec3.fromValues(0, 1.8, -0.08));
            mat4.scale(m, m, vec3.fromValues(0.45, 0.5, 0.38));
          }
          {
            const m = this.createSphere(COLOR_WHITE);
            mat4.translate(m, m, vec3.fromValues(0, 1.05, 0));
            mat4.scale(m, m, vec3.fromValues(0.3, 0.47, 0.27));
          }
          {
            const m = this.createSphere(COLOR_DARK_SILVER);
            mat4.translate(m, m, vec3.fromValues(-0.12, 1.2, -0.35));
            mat4.scale(m, m, vec3.fromValues(0.15, 0.32, 0.15));
          }
          {
            const m = this.createSphere(COLOR_DARK_SILVER);
            mat4.translate(m, m, vec3.fromValues(0.12, 1.2, -0.35));
            mat4.scale(m, m, vec3.fromValues(0.15, 0.32, 0.15));
          }
          if (this.jetpack) {
            const m = this.createSphere(4278231295);
            mat4.translate(m, m, vec3.fromValues(0, 0.9, -0.35));
            mat4.scale(m, m, vec3.fromValues(0.2, 0.2, 0.2));
            addLight(
              vec3.fromValues(this.pos[0], this.pos[1] + 1, this.pos[2]),
              vec3.fromValues(1, 0.75, 0),
            );
          }
          {
            const m = this.createSphere(COLOR_WHITE);
            mat4.translate(m, m, vec3.fromValues(-0.3, 1.4, 0));
            mat4.rotateX(m, m, leftArmRotationX);
            mat4.rotateZ(m, m, leftArmRotationZ);
            mat4.translate(m, m, vec3.fromValues(-0.4, 0, 0));
            mat4.scale(m, m, vec3.fromValues(0.4, 0.16, 0.16));
          }
          {
            const m = this.createSphere(COLOR_WHITE);
            mat4.translate(m, m, vec3.fromValues(0.3, 1.4, 0));
            mat4.rotateX(m, m, rightArmRotationX);
            mat4.rotateZ(m, m, rightArmRotationZ);
            mat4.translate(m, m, vec3.fromValues(0.4, 0, 0));
            mat4.scale(m, m, vec3.fromValues(0.4, 0.16, 0.16));
          }
          {
            const m = this.createSphere(COLOR_WHITE);
            mat4.translate(m, m, vec3.fromValues(0, 1.1, 0));
            mat4.rotateX(m, m, leftLegRotationX);
            mat4.translate(m, m, vec3.fromValues(-0.21, -0.6, 0));
            mat4.scale(m, m, vec3.fromValues(0.18, 0.6, 0.18));
          }
          {
            const m = this.createSphere(COLOR_WHITE);
            mat4.translate(m, m, vec3.fromValues(0, 1.1, 0));
            mat4.rotateX(m, m, rightLegRotationX);
            mat4.translate(m, m, vec3.fromValues(0.21, -0.6, 0));
            mat4.scale(m, m, vec3.fromValues(0.18, 0.6, 0.18));
          }
        }
      }
      class Kang extends GameEntity {
        constructor() {
          super(16, 5, 16);
          this.nextShootTime = 0;
        }
        update() {
          this.yaw = Math.atan2(
            player.pos[0] - this.pos[0],
            player.pos[2] - this.pos[2],
          );
          this.pos[1] = player.pos[1] + 6 + Math.sin(time * 2);
          this.velocity[1] = 0;
          if (
            gameState === GameState.PLAYING &&
            gameTime > this.nextShootTime &&
            player.health > 0
          ) {
            const projectile = new Particle();
            projectile.projectile = ProjectileType.Enemy;
            projectile.color = 4282401023;
            projectile.deathRate = 10;
            projectile.lightColor = vec3.fromValues(1, 0, 0);
            projectile.size = 0.5;
            vec3.copy(projectile.pos, this.pos);
            projectile.pos[1] += 3;
            const target = vec3.fromValues(
              player.pos[0],
              player.pos[1] + 1,
              player.pos[2],
            );
            vec3.subtract(projectile.velocity, target, projectile.pos);
            vec3.normalize(projectile.velocity, projectile.velocity);
            vec3.scale(projectile.velocity, projectile.velocity, 40);
            entities.push(projectile);
            this.nextShootTime = gameTime + 5;
            playKangShootSound();
          }
        }
        render() {
          mat4.identity(this.transformMatrix);
          mat4.translate(this.transformMatrix, this.transformMatrix, this.pos);
          mat4.rotateY(this.transformMatrix, this.transformMatrix, this.yaw);
          {
            const m = this.createSphere(COLOR_ALIEN_GREEN);
            mat4.scale(m, m, vec3.fromValues(3, 7, 3));
          }
          {
            const m = this.createSphere(COLOR_KANG_EYE_YELLOW);
            mat4.translate(m, m, vec3.fromValues(0, 3, 1.2));
            mat4.scale(m, m, vec3.fromValues(2, 2, 2));
          }
          {
            const remaining = this.nextShootTime - gameTime;
            const charge = Math.min((5 - remaining) / 4.5, 1);
            const color = 4281545523 + charge * 204;
            const m = this.createSphere(color);
            mat4.translate(m, m, vec3.fromValues(0, 3, 3));
            mat4.scale(m, m, vec3.fromValues(0.5, 1.2, 0.3));
          }
          for (let i = 0; i < 10; i++) {
            const m = this.createSphere(COLOR_ALIEN_GREEN);
            mat4.rotateY(m, m, (i / 10) * Math.PI * 2);
            mat4.rotateX(m, m, 0.5 + 0.4 * Math.sin(time * 4 + i));
            mat4.translate(m, m, vec3.fromValues(0, -2, 4));
            mat4.scale(m, m, vec3.fromValues(0.5, 0.5, 4));
          }
        }
      }
      const mysteryColors = [
        4294914096, 4281401088, 4281348351, 4294967088, 4294914303, 4281401343,
      ];
      class Mystery extends GameEntity {
        constructor(x, y, z, sx, sy, sz) {
          super(x, y, z);
          this.deathRate = 20;
          this.color = mysteryColors[(Math.random() * 6) | 0];
          this.scale = vec3.fromValues(sx, sy, sz);
        }
        update() {
          vec3.scaleAndAdd(this.pos, this.pos, this.velocity, dt);
          this.health -= dt * this.deathRate;
        }
        render() {
          const m = buffers[DYNAMIC_CUBES].addInstance(this.color);
          mat4.multiply(m, m, this.transformMatrix);
          mat4.scale(m, m, this.scale);
        }
      }
      const ProjectileType = { None: 0, Player: 1, Enemy: 2 };
      class Particle extends GameEntity {
        constructor(x, y, z) {
          super(x, y, z);
          this.size = 0.2;
          this.deathRate = 100;
          this.color = COLOR_WHITE;
          this.acceleration = vec3.create();
          this.lightColor = null;
          this.projectile = ProjectileType.None;
        }
        update() {
          vec3.scaleAndAdd(this.velocity, this.velocity, this.acceleration, dt);
          vec3.scaleAndAdd(this.pos, this.pos, this.velocity, dt);
          this.health -= dt * this.deathRate;
        }
        render() {
          const radius = this.size * (this.health / 100);
          const m = this.createSphere(this.color);
          mat4.scale(m, m, vec3.fromValues(radius, radius, radius));
          if (this.lightColor) addLight(this.pos, this.lightColor);
        }
      }
      class Platform extends GameEntity {
        constructor(x, y, z) {
          super(x, y, z);
          this.color = COLOR_SILVER;
          this.scale = vec3.fromValues(1, 1, 1);
          this.waypoints = [];
          this.waypointIndex = 0;
        }
        update() {
          const waypoint = this.updateWaypoints();
          if (waypoint) {
            vec3.subtract(this.velocity, waypoint, this.pos);
            vec3.normalize(this.velocity, this.velocity);
            vec3.scale(this.velocity, this.velocity, 6);
            vec3.scaleAndAdd(this.pos, this.pos, this.velocity, dt);
          }
        }
        render() {
          if (this.waypoints.length > 0) {
            {
              const m = buffers[DYNAMIC_CUBES].addInstance(COLOR_YELLOW);
              mat4.multiply(m, m, this.transformMatrix);
              mat4.scale(m, m, this.scale);
            }
            {
              const m = buffers[DYNAMIC_CUBES].addInstance(COLOR_BLACK);
              mat4.multiply(m, m, this.transformMatrix);
              mat4.rotateY(m, m, Math.PI / 4);
              mat4.scale(m, m, vec3.fromValues(2.5, 0.31, 0.32));
            }
            {
              const m = buffers[DYNAMIC_CUBES].addInstance(COLOR_BLACK);
              mat4.multiply(m, m, this.transformMatrix);
              mat4.rotateY(m, m, Math.PI / 4);
              mat4.translate(m, m, vec3.fromValues(0, 0, -1.2));
              mat4.scale(m, m, vec3.fromValues(1.35, 0.31, 0.32));
            }
            {
              const m = buffers[DYNAMIC_CUBES].addInstance(COLOR_BLACK);
              mat4.multiply(m, m, this.transformMatrix);
              mat4.rotateY(m, m, Math.PI / 4);
              mat4.translate(m, m, vec3.fromValues(0, 0, 1.2));
              mat4.scale(m, m, vec3.fromValues(1.35, 0.31, 0.32));
            }
            {
              const m = buffers[DYNAMIC_CUBES].addInstance(COLOR_BLACK);
              mat4.multiply(m, m, this.transformMatrix);
              mat4.translate(m, m, vec3.fromValues(0, 0, -1.82));
              mat4.scale(m, m, vec3.fromValues(2.04, 0.32, 0.2));
            }
            {
              const m = buffers[DYNAMIC_CUBES].addInstance(COLOR_BLACK);
              mat4.multiply(m, m, this.transformMatrix);
              mat4.translate(m, m, vec3.fromValues(0, 0, 1.82));
              mat4.scale(m, m, vec3.fromValues(2.04, 0.32, 0.2));
            }
            {
              const m = buffers[DYNAMIC_CUBES].addInstance(COLOR_BLACK);
              mat4.multiply(m, m, this.transformMatrix);
              mat4.translate(m, m, vec3.fromValues(-1.82, 0, 0));
              mat4.scale(m, m, vec3.fromValues(0.2, 0.32, 2.04));
            }
            {
              const m = buffers[DYNAMIC_CUBES].addInstance(COLOR_BLACK);
              mat4.multiply(m, m, this.transformMatrix);
              mat4.translate(m, m, vec3.fromValues(1.82, 0, 0));
              mat4.scale(m, m, vec3.fromValues(0.2, 0.32, 2.04));
            }
          } else {
            const m = buffers[DYNAMIC_CUBES].addInstance(this.color);
            mat4.multiply(m, m, this.transformMatrix);
            mat4.scale(m, m, this.scale);
          }
        }
      }
      class Shooter extends GameEntity {
        constructor(x, y, z, yaw, nextShootTime) {
          super(x, y, z);
          this.yaw = yaw;
          this.nextShootTime = nextShootTime;
        }
        update() {
          this.pos[1] += dt * 0.5 * Math.sin(time * 2);
          this.velocity[1] = 0;
          if (
            gameState === GameState.PLAYING &&
            gameTime > this.nextShootTime &&
            player.health > 0
          ) {
            const projectile = new Particle();
            projectile.projectile = ProjectileType.Enemy;
            projectile.color = 4282401023;
            projectile.deathRate = 10;
            projectile.lightColor = vec3.fromValues(1, 0, 0);
            projectile.size = 0.5;
            vec3.copy(projectile.pos, this.pos);
            projectile.pos[1] += 0.75;
            vec3.rotateY(projectile.velocity, forward, origin, this.yaw);
            vec3.scale(projectile.velocity, projectile.velocity, 20);
            entities.push(projectile);
            this.nextShootTime = gameTime + 5;
            playKangShootSound();
          }
        }
        render() {
          mat4.identity(this.transformMatrix);
          mat4.translate(this.transformMatrix, this.transformMatrix, this.pos);
          mat4.rotateY(this.transformMatrix, this.transformMatrix, this.yaw);
          {
            const m = this.createSphere(COLOR_ALIEN_GREEN);
            mat4.translate(m, m, vec3.fromValues(0, 0.8, 0));
            mat4.scale(m, m, vec3.fromValues(0.5, 0.5, 0.5));
          }
          {
            const m = this.createSphere(COLOR_SILVER);
            mat4.translate(m, m, vec3.fromValues(0, 0.4, 0));
            mat4.scale(m, m, vec3.fromValues(0.5, 0.5, 0.5));
          }
          {
            const m = this.createSphere(4278231295);
            mat4.translate(m, m, vec3.fromValues(0, -0.2, 0));
            mat4.scale(m, m, vec3.fromValues(0.3, 0.3, 0.3));
          }
          {
            const m = this.createSphere(COLOR_BLACK);
            mat4.translate(m, m, vec3.fromValues(-0.25, 1, 0.4));
            mat4.rotateZ(m, m, -1);
            mat4.scale(m, m, vec3.fromValues(0.15, 0.1, 0.1));
          }
          {
            const m = this.createSphere(COLOR_BLACK);
            mat4.translate(m, m, vec3.fromValues(0.25, 1, 0.4));
            mat4.rotateZ(m, m, 1);
            mat4.scale(m, m, vec3.fromValues(0.15, 0.1, 0.1));
          }
        }
      }
      class Spaceship extends GameEntity {
        render() {
          const white = COLOR_WHITE;
          const orange = COLOR_ORANGE;
          const silver = COLOR_DARK_SILVER;
          {
            const m = this.createSphere(white);
            mat4.scale(m, m, vec3.fromValues(5, 1, 1.3));
          }
          {
            const m = this.createSphere(orange);
            mat4.translate(m, m, vec3.fromValues(1.5, 0.5, 0));
            mat4.scale(m, m, vec3.fromValues(2, 0.6, 0.8));
          }
          {
            const m = this.createSphere(white);
            mat4.translate(m, m, vec3.fromValues(0, 0, 2));
            mat4.rotateY(m, m, 0.5);
            mat4.scale(m, m, vec3.fromValues(3, 0.3, 1));
          }
          {
            const m = this.createSphere(white);
            mat4.translate(m, m, vec3.fromValues(0, 0, -2));
            mat4.rotateY(m, m, -0.5);
            mat4.scale(m, m, vec3.fromValues(3, 0.3, 1));
          }
          {
            const m = this.createSphere(silver);
            mat4.translate(m, m, vec3.fromValues(-3, 0.3, 0.7));
            mat4.scale(m, m, vec3.fromValues(3, 0.5, 0.5));
          }
          {
            const m = this.createSphere(silver);
            mat4.translate(m, m, vec3.fromValues(-3, 0.3, -0.7));
            mat4.scale(m, m, vec3.fromValues(3, 0.5, 0.5));
          }
        }
      }
      const zzfxV = 0.3;
      const zzfxG = (
        volume = 1,
        randomness = 0.05,
        frequency = 220,
        attack = 0,
        sustain = 0,
        release = 0.1,
        shape = 0,
        shapeCurve = 1,
        slide = 0,
        deltaSlide = 0,
        pitchJump = 0,
        pitchJumpTime = 0,
        repeatTime = 0,
        noise = 0,
        modulation = 0,
        bitCrush = 0,
        delay = 0,
        sustainVolume = 1,
        decay = 0,
        tremolo = 0,
      ) => {
        const PI2 = Math.PI * 2;
        let sign = (v) => (v > 0 ? 1 : -1),
          startSlide = (slide *= (500 * PI2) / zzfxR / zzfxR),
          startFrequency = (frequency *= PI2 / zzfxR),
          b = [],
          t = 0,
          tm = 0,
          i = 0,
          j = 1,
          r = 0,
          c = 0,
          s = 0,
          f,
          length;
        attack = attack * zzfxR + 9;
        decay *= zzfxR;
        sustain *= zzfxR;
        release *= zzfxR;
        delay *= zzfxR;
        deltaSlide *= (500 * PI2) / zzfxR ** 3;
        modulation *= PI2 / zzfxR;
        pitchJump *= PI2 / zzfxR;
        pitchJumpTime *= zzfxR;
        repeatTime = (repeatTime * zzfxR) | 0;
        for (
          length = (attack + decay + sustain + release + delay) | 0;
          i < length;
          b[i++] = s
        ) {
          if (!(++c % ((bitCrush * 100) | 0))) {
            s = shape
              ? shape > 1
                ? shape > 2
                  ? shape > 3
                    ? Math.sin((t % PI2) ** 3)
                    : Math.max(Math.min(Math.tan(t), 1), -1)
                  : 1 - (((((2 * t) / PI2) % 2) + 2) % 2)
                : 1 - 4 * Math.abs(Math.round(t / PI2) - t / PI2)
              : Math.sin(t);
            s =
              (repeatTime
                ? 1 - tremolo + tremolo * Math.sin((PI2 * i) / repeatTime)
                : 1) *
              sign(s) *
              Math.abs(s) ** shapeCurve *
              volume *
              zzfxV *
              (i < attack
                ? i / attack
                : i < attack + decay
                ? 1 - ((i - attack) / decay) * (1 - sustainVolume)
                : i < attack + decay + sustain
                ? sustainVolume
                : i < length - delay
                ? ((length - i - delay) / release) * sustainVolume
                : 0);
            s = delay
              ? s / 2 +
                (delay > i
                  ? 0
                  : ((i < length - delay ? 1 : (length - i) / delay) *
                      b[(i - delay) | 0]) /
                    2)
              : s;
          }
          f = (frequency += slide += deltaSlide) * Math.cos(modulation * tm++);
          t += f - f * noise * (1 - (((Math.sin(i) + 1) * 1e9) % 2));
          if (j && ++j > pitchJumpTime) {
            frequency += pitchJump;
            startFrequency += pitchJump;
            j = 0;
          }
          if (repeatTime && !(++r % repeatTime)) {
            frequency = startFrequency;
            slide = startSlide;
            j = j || 1;
          }
        }
        return b;
      };
      const zzfxP = (...t) => {
        const e = zzfxX.createBufferSource();
        const f = zzfxX.createBuffer(t.length, t[0].length, zzfxR);
        t.map((d, i) => f.getChannelData(i).set(d));
        e.buffer = f;
        e.connect(zzfxX.destination);
        e.connect(reverbConvolver);
        e.start();
        return e;
      };
      const zzfx = (...t) => zzfxP(zzfxG(...t));
      const zzfxX = new AudioContext();
      const zzfxR = 44100;
      function createReverbConvolver(duration) {
        const sampleRate = zzfxX.sampleRate;
        const length = sampleRate * duration;
        const impulse = zzfxX.createBuffer(2, length, sampleRate);
        const impulseL = impulse.getChannelData(0);
        const impulseR = impulse.getChannelData(1);
        const decay = 1.5;
        for (let i = 0; i < length; i++) {
          impulseL[i] =
            0.5 * (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
          impulseR[i] =
            0.5 * (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        const convolver = zzfxX.createConvolver();
        convolver.buffer = impulse;
        convolver.connect(zzfxX.destination);
        return convolver;
      }
      const reverbConvolver = createReverbConvolver(1);
      const Channel = {};
      const Pattern = {};
      const Instrument = {};
      const boolToInt = (b) => (b ? 1 : 0);
      const zzfxM = (instruments, patterns, sequence, BPM = 125) => {
        let instrumentParameters;
        let i;
        let j;
        let k;
        let note;
        let sample;
        let patternChannel;
        let notFirstBeat;
        let stop;
        let instrument;
        let attenuation;
        let outSampleOffset;
        let isSequenceEnd;
        let sampleOffset = 0;
        let nextSampleOffset;
        let sampleBuffer = [];
        const leftChannelBuffer = [];
        const rightChannelBuffer = [];
        let channelIndex = 0;
        let panning = 0;
        let hasMore = 1;
        const sampleCache = {};
        const beatLength = ((zzfxR / BPM) * 60) >> 2;
        for (; hasMore; channelIndex++) {
          sampleBuffer = [(hasMore = notFirstBeat = outSampleOffset = 0)];
          sequence.map((patternIndex, sequenceIndex) => {
            patternChannel = patterns[patternIndex][channelIndex] || [0, 0, 0];
            hasMore |= boolToInt(!!patterns[patternIndex][channelIndex]);
            nextSampleOffset =
              outSampleOffset +
              (patterns[patternIndex][0].length -
                2 -
                boolToInt(!notFirstBeat)) *
                beatLength;
            isSequenceEnd = sequenceIndex == sequence.length - 1;
            for (
              i = 2, k = outSampleOffset;
              i < patternChannel.length + isSequenceEnd;
              notFirstBeat = ++i
            ) {
              note = patternChannel[i];
              stop =
                (i == patternChannel.length + isSequenceEnd - 1 &&
                  isSequenceEnd) ||
                boolToInt(instrument != (patternChannel[0] || 0)) | note | 0;
              j = 0;
              while (j < beatLength && notFirstBeat) {
                sample =
                  ((1 - attenuation) * sampleBuffer[sampleOffset++]) / 2 || 0;
                leftChannelBuffer[k] =
                  (leftChannelBuffer[k] || 0) - sample * panning + sample;
                rightChannelBuffer[k] =
                  (rightChannelBuffer[k++] || 0) + sample * panning + sample;
                if (j++ > beatLength - 99 && stop)
                  attenuation += boolToInt(attenuation < 1) / 99;
              }
              if (note) {
                attenuation = note % 1;
                panning = patternChannel[1] || 0;
                if ((note |= 0))
                  sampleBuffer = sampleCache[
                    [
                      (instrument = patternChannel[(sampleOffset = 0)] || 0),
                      note,
                    ]
                  ] =
                    sampleCache[[instrument, note]] ||
                    ((instrumentParameters = [...instruments[instrument]]),
                    (instrumentParameters[2] *= 2 ** ((note - 12) / 12)),
                    note > 0 ? zzfxG(...instrumentParameters) : []);
              }
            }
            outSampleOffset = nextSampleOffset;
          });
        }
        return [leftChannelBuffer, rightChannelBuffer];
      };
      const playJumpSound = () =>
        zzfx(...[0.6, 0, 130, 0.01, 0.02, , , 0.4, 5, , , , , , , , , 0.9]);
      const playCoinSound = () =>
        zzfx(
          ...[
            0.7,
            0,
            1e3 * (1 + 1 / 12) ** coinSequence,
            ,
            0.05,
            ,
            1,
            1.5,
            ,
            ,
            300,
            0.1,
            ,
            ,
            ,
            ,
            ,
            0.5,
            0.05,
          ],
        );
      const playFuelSound = () =>
        zzfx(
          ...[
            0.5,
            0,
            328,
            0.04,
            0.1,
            0.35,
            ,
            0.97,
            ,
            0.5,
            9,
            0.01,
            0.06,
            ,
            12,
            0.1,
            ,
            0.74,
            0.08,
          ],
        );
      const playShootSound = () =>
        zzfx(
          ...[
            0.3,
            0,
            40,
            0.02,
            0.02,
            0.04,
            4,
            0.87,
            ,
            0.9,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            0.83,
            0.02,
            0.28,
          ],
        );
      const playKangShootSound = () =>
        zzfx(
          ...[
            0.2,
            0,
            20,
            0.02,
            0.1,
            ,
            4,
            0.87,
            ,
            0.9,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            0.83,
            0.02,
            0.28,
          ],
        );
      const playExplosionSound = () =>
        zzfx(
          ...[
            0.5,
            0,
            101,
            ,
            ,
            0.5,
            4,
            2.8,
            ,
            ,
            ,
            ,
            ,
            ,
            0.8,
            0.4,
            ,
            0.95,
            ,
            0.42,
          ],
        );
      const playMenuBeep = () =>
        zzfx(
          ...[
            0.5,
            0,
            80,
            0.02,
            0.04,
            0.02,
            1,
            0.3,
            56,
            ,
            ,
            ,
            ,
            0.1,
            7.5,
            ,
            ,
            0.39,
          ],
        );
      const jetpackAudioBuffer = zzfxG(
        ...[0.05, 0, 900, 0.2, 3, 0, 4, 0, , , , , , 4, , 0.1],
      );
      let jetpackSound;
      const startJetpackSound = () => {
        if (!jetpackSound) {
          jetpackSound = zzfxP(jetpackAudioBuffer);
          jetpackSound.loop = true;
        }
      };
      const stopJetpackSound = () => {
        if (jetpackSound) {
          jetpackSound.stop();
          jetpackSound = null;
        }
      };
      const milkyWaySong = [
        [
          [, 0, 240, 0.01, 0.09, 0.2, 1, 2, , , , , , , , , , 0.5],
          [0.1, 0, 120, , 0.07, 0.07, 1, 0, , , 0.5, 0.01],
          [0.8, 0, 240, 0.01, 0.4, 0.2, 1, 2, , , , , , , , , , 0.5],
        ],
        [
          [
            [
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
            ],
            [
              1,
              ,
              24,
              24,
              20,
              20,
              17,
              17,
              17,
              24,
              22,
              22,
              19,
              19,
              15,
              15,
              15,
              22,
              24,
              24,
              20,
              20,
              8,
              13,
              8,
              8,
              22,
              22,
              22,
              15,
              15,
              19,
              15,
              22,
              24,
              24,
              20,
              20,
              17,
              17,
              17,
              24,
              22,
              22,
              19,
              19,
              15,
              15,
              15,
              22,
              24,
              24,
              20,
              20,
              8,
              13,
              8,
              8,
              22,
              22,
              22,
              15,
              15,
              19,
              15,
              22,
            ],
            [
              1,
              ,
              24,
              17,
              20,
              15,
              17,
              8,
              5,
              24,
              22,
              15,
              19,
              10,
              15,
              7,
              3,
              22,
              24,
              19,
              20,
              13,
              8,
              8,
              8,
              5,
              22,
              10,
              3,
              15,
              3,
              19,
              15,
              22,
              24,
              17,
              20,
              12,
              17,
              8,
              5,
              24,
              22,
              15,
              19,
              10,
              15,
              7,
              3,
              22,
              24,
              19,
              20,
              13,
              8,
              8,
              8,
              5,
              22,
              10,
              3,
              15,
              3,
              19,
              15,
              22,
            ],
          ],
          [
            [
              2,
              ,
              20,
              ,
              ,
              17,
              ,
              ,
              20,
              ,
              19,
              ,
              17,
              ,
              15,
              ,
              12,
              ,
              17,
              ,
              ,
              ,
              12,
              ,
              ,
              ,
              15,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              24,
              ,
              ,
              17,
              ,
              ,
              24,
              ,
              22,
              ,
              20,
              ,
              19,
              ,
              15,
              ,
              17,
              ,
              ,
              ,
              20,
              ,
              ,
              ,
              19,
              ,
              ,
              ,
              22,
              ,
              ,
              ,
            ],
            [
              1,
              ,
              24,
              24,
              20,
              20,
              17,
              17,
              17,
              24,
              22,
              22,
              19,
              19,
              15,
              15,
              15,
              22,
              24,
              24,
              20,
              20,
              8,
              13,
              8,
              8,
              22,
              22,
              22,
              15,
              15,
              19,
              15,
              22,
              24,
              24,
              20,
              20,
              17,
              17,
              17,
              24,
              22,
              22,
              19,
              19,
              15,
              15,
              15,
              22,
              24,
              24,
              20,
              20,
              8,
              13,
              8,
              8,
              22,
              22,
              22,
              15,
              15,
              19,
              15,
              22,
            ],
            [
              1,
              ,
              24,
              17,
              20,
              15,
              17,
              8,
              5,
              24,
              22,
              15,
              19,
              10,
              15,
              7,
              3,
              22,
              24,
              19,
              20,
              13,
              8,
              8,
              8,
              5,
              22,
              10,
              3,
              15,
              3,
              19,
              15,
              22,
              24,
              17,
              20,
              12,
              17,
              8,
              5,
              24,
              22,
              15,
              19,
              10,
              15,
              7,
              3,
              22,
              24,
              19,
              20,
              13,
              8,
              8,
              8,
              5,
              22,
              10,
              3,
              15,
              3,
              19,
              15,
              22,
            ],
          ],
          [
            [
              2,
              ,
              17,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              15,
              ,
              ,
              ,
              10,
              ,
              ,
              ,
              17,
              ,
              ,
              ,
              ,
              ,
              20,
              ,
              19,
              ,
              ,
              ,
              22,
              ,
              ,
              ,
              24,
              ,
              ,
              ,
              17,
              ,
              ,
              ,
              24,
              ,
              22,
              ,
              20,
              ,
              19,
              ,
              17,
              ,
              ,
              ,
              ,
              ,
              19,
              17,
              19,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
            ],
            [
              1,
              ,
              24,
              24,
              20,
              20,
              17,
              17,
              17,
              24,
              22,
              22,
              19,
              19,
              15,
              15,
              15,
              22,
              24,
              24,
              20,
              20,
              8,
              13,
              8,
              8,
              22,
              22,
              22,
              15,
              15,
              19,
              15,
              22,
              24,
              24,
              20,
              20,
              17,
              17,
              17,
              24,
              22,
              22,
              19,
              19,
              15,
              15,
              15,
              22,
              24,
              24,
              20,
              20,
              8,
              13,
              8,
              8,
              22,
              22,
              22,
              15,
              15,
              19,
              15,
              22,
            ],
            [
              1,
              ,
              24,
              17,
              20,
              15,
              17,
              8,
              5,
              24,
              22,
              15,
              19,
              10,
              15,
              7,
              3,
              22,
              24,
              19,
              20,
              13,
              8,
              8,
              8,
              5,
              22,
              10,
              3,
              15,
              3,
              19,
              15,
              22,
              24,
              17,
              20,
              12,
              17,
              8,
              5,
              24,
              22,
              15,
              19,
              10,
              15,
              7,
              3,
              22,
              24,
              19,
              20,
              13,
              8,
              8,
              8,
              5,
              22,
              10,
              3,
              15,
              3,
              19,
              15,
              22,
            ],
          ],
          [
            [
              2,
              ,
              24,
              ,
              20,
              ,
              17,
              ,
              ,
              24,
              22,
              ,
              19,
              ,
              15,
              ,
              ,
              22,
              24,
              ,
              22,
              ,
              ,
              ,
              ,
              ,
              22,
              ,
              ,
              15,
              ,
              19,
              15,
              22,
              24,
              ,
              20,
              ,
              17,
              ,
              ,
              24,
              22,
              ,
              19,
              ,
              15,
              ,
              ,
              22,
              24,
              ,
              20,
              ,
              ,
              ,
              ,
              ,
              22,
              ,
              ,
              15,
              ,
              19,
              15,
              22,
            ],
            [
              1,
              ,
              24,
              24,
              20,
              20,
              17,
              17,
              17,
              24,
              22,
              22,
              19,
              19,
              15,
              15,
              15,
              22,
              24,
              24,
              20,
              20,
              8,
              13,
              8,
              8,
              22,
              22,
              22,
              15,
              15,
              19,
              15,
              22,
              24,
              24,
              20,
              20,
              17,
              17,
              17,
              24,
              22,
              22,
              19,
              19,
              15,
              15,
              15,
              22,
              24,
              24,
              20,
              20,
              8,
              13,
              8,
              8,
              22,
              22,
              22,
              15,
              15,
              19,
              15,
              22,
            ],
            [
              1,
              ,
              24,
              17,
              20,
              15,
              17,
              8,
              5,
              24,
              22,
              15,
              19,
              10,
              15,
              7,
              3,
              22,
              24,
              19,
              20,
              13,
              8,
              8,
              8,
              5,
              22,
              10,
              3,
              15,
              3,
              19,
              15,
              22,
              24,
              17,
              20,
              12,
              17,
              8,
              5,
              24,
              22,
              15,
              19,
              10,
              15,
              7,
              3,
              22,
              24,
              19,
              20,
              13,
              8,
              8,
              8,
              5,
              22,
              10,
              3,
              15,
              3,
              19,
              15,
              22,
            ],
          ],
        ],
        [0, 1, 2, 3],
        70,
      ];
      const deathSongData = [
        [
          [0.9, 0, 240, 0.01, 0.09, 0.2, 1, 2, , , , , , , , , , 0.5],
          [0.2, 0, 120, , 0.07, 0.07, 1, 0, , , 0.5, 0.01],
        ],
        [
          [
            [
              ,
              ,
              27,
              ,
              26,
              ,
              25,
              ,
              24,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
            ],
            [
              ,
              ,
              15,
              ,
              14,
              ,
              13,
              ,
              12,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
            ],
            [
              1,
              ,
              15,
              15,
              14,
              14,
              13,
              13,
              12,
              12,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
            ],
          ],
        ],
        [0],
      ];
      const flagpoleSongData = [
        [
          [0.9, 0, 240, 0.01, 0.09, 0.2, 1, 2, , , , , , , , , , 0.5],
          [0.2, 0, 120, , 0.07, 0.07, 1, 0, , , 0.5, 0.01],
          [0.9, 0, 240, 0.01, 0.4, 0.2, 1, 2, , , , , , , , , , 0.5],
        ],
        [
          [
            [
              ,
              ,
              1,
              1,
              1,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
            ],
            [
              ,
              ,
              5,
              5,
              5,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
            ],
            [
              ,
              ,
              8,
              8,
              8,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
            ],
            [
              2,
              ,
              ,
              ,
              ,
              ,
              8,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
            ],
            [
              2,
              ,
              ,
              ,
              ,
              ,
              12,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
            ],
            [
              2,
              ,
              ,
              ,
              ,
              ,
              15,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
              ,
            ],
          ],
        ],
        [0],
      ];
      let backgroundMusicNode = null;
      const playMusic = (songData, loop) => {
        const buffer = zzfxM(...songData);
        const node = zzfxP(...buffer);
        if (loop) {
          stopBackgroundMusic();
          node.loop = true;
          backgroundMusicNode = node;
        }
      };
      const stopBackgroundMusic = () => {
        if (backgroundMusicNode) {
          backgroundMusicNode.stop();
          backgroundMusicNode = null;
        }
      };
      const toggleBackgroundMusic = () => {
        if (backgroundMusicNode) {
          stopBackgroundMusic();
          localStorage["music-off"] = "t";
        } else {
          playMusic(milkyWaySong, true);
          localStorage.removeItem("music-off");
        }
      };
      const ACCELERATION = 100;
      const FRICTION = 8;
      const GRAVITY = 40;
      const FLOATY_GRAVITY = 20;
      const JUMP_GRACE_TIME = 0.25;
      const JUMP_POWER = 12;
      const MAX_X = 32;
      const MAX_Y = 64;
      const MAX_Z = 32;
      const TILE_SIZE = 1;
      const STATIC_CUBES = 0;
      const STATIC_SPHERES = 1;
      const DYNAMIC_CUBES = 2;
      const DYNAMIC_SPHERES = 3;
      const COLOR_STARS = 4278190080;
      const COLOR_DARK_GREEN = 4282685713;
      const COLOR_MEDIUM_GREEN = 4283808597;
      const COLOR_LIGHT_GREEN = 4285575280;
      const COLOR_BLACK = 4281545523;
      const COLOR_WHITE = 4293980400;
      const COLOR_ORANGE = 4279352304;
      const COLOR_RED = 4279313117;
      const COLOR_YELLOW = 4282710264;
      const COLOR_SILVER = 4291607466;
      const COLOR_DARK_SILVER = 4289374368;
      const COLOR_DARK_BLUE = 4289366118;
      const COLOR_LIGHT_BLUE = 4289374839;
      const COLOR_ALIEN_GREEN = 4279422123;
      const COLOR_KANG_EYE_YELLOW = 4289130736;
      function drawHud() {
        if (gameState === GameState.CREDITS) {
          setTextAlign(ALIGN_CENTER);
          setFontSize(24, "italic");
          drawShadowText("THE ADVENTURES OF", CENTER_X, 60);
          setFontSize(64, "italic");
          drawShadowText("CAPTAIN CALLISTO", CENTER_X, 120);
          setFontSize(72, "italic");
          setTextAlign(ALIGN_CENTER);
          drawShadowText("THANK YOU FOR PLAYING", CENTER_X, CENTER_Y);
          return;
        }
        setFontSize(48);
        setTextAlign(ALIGN_LEFT);
        drawShadowText(
          "\u2b50 " + coins + " / " + availableCoins,
          20,
          IS_FULLSCREEN ? 20 : 80,
          OVERLAY_YELLOW,
        );
        drawShadowText(
          "\ud83d\ude80 " + player.fuel.toFixed(0) + "%",
          20,
          IS_FULLSCREEN ? 100 : 160,
        );
        setTextAlign(ALIGN_RIGHT);
        drawShadowText(
          gameTime.toFixed(1),
          WIDTH - 20,
          OS !== "mac" ? 80 : 20,
          OVERLAY_LIGHT_GRAY,
        );
        setFontSize(24);
        setTextAlign(ALIGN_CENTER);
        drawKeyIcon("W", WIDTH - 445, HEIGHT - 370);
        drawKeyIcon("A", WIDTH - 490, HEIGHT - 325);
        drawKeyIcon("S", WIDTH - 445, HEIGHT - 325);
        drawKeyIcon("D", WIDTH - 400, HEIGHT - 325);
        drawKeyIcon("\u2b06", WIDTH - 295, HEIGHT - 370);
        drawKeyIcon("\u2b05", WIDTH - 340, HEIGHT - 325);
        drawKeyIcon("\u2b07", WIDTH - 295, HEIGHT - 325);
        drawKeyIcon("\u27a1", WIDTH - 250, HEIGHT - 325);
        drawKeyIcon("SPACE", WIDTH - 327, HEIGHT - 270, 100);
        drawKeyIcon("Z", WIDTH - 250, HEIGHT - 270);
        drawKeyIcon("SHIFT", WIDTH - 327, HEIGHT - 215, 100);
        drawKeyIcon("X", WIDTH - 250, HEIGHT - 215);
        drawKeyIcon("R", WIDTH - 250, HEIGHT - 160);
        drawKeyIcon("M", WIDTH - 250, HEIGHT - 105);
        drawKeyIcon("ESC", WIDTH - 262, HEIGHT - 50, 60);
        setTextAlign(ALIGN_LEFT);
        drawShadowText("Move", WIDTH - 210, HEIGHT - 315, OVERLAY_LIGHT_GRAY);
        drawShadowText("Jump", WIDTH - 210, HEIGHT - 270, OVERLAY_LIGHT_GRAY);
        drawShadowText(
          "Jetpack",
          WIDTH - 210,
          HEIGHT - 215,
          OVERLAY_LIGHT_GRAY,
        );
        drawShadowText(
          "Restart level",
          WIDTH - 210,
          HEIGHT - 160,
          OVERLAY_LIGHT_GRAY,
        );
        drawShadowText(
          "Toggle music",
          WIDTH - 210,
          HEIGHT - 105,
          OVERLAY_LIGHT_GRAY,
        );
        drawShadowText(
          "Main menu",
          WIDTH - 210,
          HEIGHT - 50,
          OVERLAY_LIGHT_GRAY,
        );
      }
      function drawDebugOverlay() {
        if (DEBUG) {
          setTextAlign(ALIGN_LEFT);
          setFontSize(20);
          drawShadowText("Player: " + vec3.str(player.pos), 10, 300);
          drawShadowText("Focus dist: " + cameraDistance.toFixed(2), 10, 340);
          drawShadowText("Camera: " + vec3.str(camera.source), 10, 360);
          drawShadowText("Menu: " + !!menu, 10, 380);
          drawShadowText("State: " + gameState, 10, 400);
          drawShadowText("Level: " + level, 10, 420);
          setTextAlign(ALIGN_CENTER);
          setFontSize(24);
          drawShadowText(
            "FPS: " + averageFps.toFixed(0),
            CENTER_X,
            HEIGHT - 50,
            OVERLAY_LIGHT_GRAY,
          );
        }
      }
      const introText = [
        ,
        [
          [
            "OUR HERO, CAPTAIN CALLISTO, BLASTS THROUGH SPACE",
            "SEEKING ADVENTURE",
          ],
        ],
        [
          [
            "APPROACHING THE ZETA AIR FORTRESS",
            "BEWARE: SENSORS SHOW SIGNS OF LIFE",
          ],
        ],
        [
          ,
          ["COLLECT ALL TREASURE AND", "REACH THE TRANSPORTER TO PROCEED"],
          ["THE PATH IS TREACHEROUS", "PROCEED WITH CAUTION"],
          ["THERE'S MORE THAN ONE WAY TO SKIN A WOMP RAT", ""],
          ["MORE ALIEN ACTIVITY THAN EXPECTED", "PROCEED WITH CAUTION"],
          ["WE ARE DEEP INTO ALIEN TERRITORY", "HIGH ALERT"],
          [
            "EVIDENCE OF COMPLEX CIVILIZATION",
            "DO NOT UNDERESTIMATE THE ENEMY",
          ],
          ["ALIEN DEFENSES ARRIVED", "WATCH OUT FOR MISSILES"],
          ["CLIMB THE GREAT PYRAMID", "TREASURE AWAITS"],
          ["THE GREAT SPIRES OF KODOS", "WE MUST BE NEAR!"],
          ["THE INNER SANCTUM!  THE GREAT KANG!", "YOU ARE DOOMED!"],
        ],
        [["OH NO!", "TRY AGAIN!"]],
      ];
      let Menu;
      const levelIntro = () => ({
        callback: () => {
          gameState = GameState.PLAYING;
          gameTime = 0;
          setMenu(null);
        },
      });
      const deathScreen = {
        callback: () => {
          gameState = GameState.BEFORE_LEVEL;
          showLevelIntro();
        },
      };
      const winScreen = {
        callback: () => {
          gameState = GameState.BEFORE_LEVEL;
          setLevel(level + 1);
          showLevelIntro();
        },
      };
      const clickToStart = {
        callback: () => {
          if (gameState === 0) {
            zzfxX.resume();
            if (!localStorage["music-off"]) playMusic(milkyWaySong, true);
          }
          if (++gameState > GameState.INTRO_STORY2) {
            setLevel(1);
            showLevelIntro();
          }
        },
      };
      const mainMenu = {
        callback: () => {
          log("main menu callback");
        },
      };
      const levelsMenu = {
        callback: () => {
          log("levels menu callback");
        },
      };
      let menuStartTime = 0;
      let menu = clickToStart;
      let prevMenu = null;
      let menuY = 0;
      function setMenu(m) {
        prevMenu = menu;
        menuStartTime = time;
        menu = m;
        menuY = 0;
      }
      function showLevelIntro() {
        initGame();
        setMenu(levelIntro());
      }
      const drawMenu = () => {
        if (
          gameState === GameState.CREDITS &&
          menu !== mainMenu &&
          menu !== levelsMenu
        ) {
          menu = null;
          return;
        }
        if (
          gameState <= GameState.INTRO_STORY2 ||
          menu === mainMenu ||
          menu == levelsMenu
        ) {
          setTextAlign(ALIGN_CENTER);
          setFontSize(24, "italic");
          drawShadowText("THE ADVENTURES OF", CENTER_X, 60);
          setFontSize(64, "italic");
          drawShadowText("CAPTAIN CALLISTO", CENTER_X, 120);
        }
        if (menu === mainMenu) {
          setTextAlign(ALIGN_LEFT);
          setFontSize(48, "italic");
          drawShadowText(
            "NEW GAME",
            250,
            400,
            menuY === 0 ? OVERLAY_YELLOW : OVERLAY_WHITE,
          );
          drawShadowText(
            "CONTINUE",
            250,
            500,
            menuY === 1 ? OVERLAY_YELLOW : OVERLAY_WHITE,
          );
          drawShadowText(
            "LEVELS",
            250,
            600,
            menuY === 2 ? OVERLAY_YELLOW : OVERLAY_WHITE,
          );
          if (isKeyPressed(KEY_UP) || isKeyPressed(KEY_W)) {
            menuY = (menuY + 2) % 3;
            playMenuBeep();
          }
          if (isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S)) {
            menuY = (menuY + 1) % 3;
            playMenuBeep();
          }
          if (isKeyPressed(KEY_ESCAPE)) {
            resetKeys();
            setMenu(prevMenu);
            playMenuBeep();
          }
          if (
            isKeyPressed(KEY_ENTER) ||
            isKeyPressed(KEY_SPACE) ||
            isKeyPressed(KEY_Z)
          ) {
            if (menuY === 0) {
              gameState = GameState.INTRO_STORY1;
              setLevel(0);
              initGame();
              setMenu(clickToStart);
              playMenuBeep();
            }
            if (menuY === 1) {
              setMenu(null);
              playMenuBeep();
            }
            if (menuY === 2) {
              setMenu(levelsMenu);
              playMenuBeep();
            }
          }
          return;
        }
        if (menu === levelsMenu) {
          setFontSize(32, "italic");
          for (let i = 0; i < 10; i++) {
            setTextAlign(ALIGN_LEFT);
            drawShadowText(
              `LEVEL ${i + 1}`,
              250,
              350 + i * 60,
              menuY === i ? OVERLAY_YELLOW : OVERLAY_WHITE,
            );
            const bestTime = bestTimes[i + 1];
            if (bestTime) {
              setTextAlign(ALIGN_RIGHT);
              drawShadowText(
                `${bestTime.toFixed(1)} sec`,
                600,
                350 + i * 60,
                OVERLAY_LIGHT_GRAY,
              );
            }
          }
          if (isKeyPressed(KEY_UP) || isKeyPressed(KEY_W)) {
            menuY = (menuY + 9) % 10;
            playMenuBeep();
          }
          if (isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S)) {
            menuY = (menuY + 1) % 10;
            playMenuBeep();
          }
          if (isKeyPressed(KEY_ESCAPE)) {
            setMenu(prevMenu);
            playMenuBeep();
          }
          if (
            isKeyPressed(KEY_ENTER) ||
            isKeyPressed(KEY_SPACE) ||
            isKeyPressed(KEY_Z)
          ) {
            gameState = GameState.BEFORE_LEVEL;
            setLevel(menuY + 1);
            showLevelIntro();
            playMenuBeep();
          }
          return;
        }
        const canContinue = time - menuStartTime > 0.5;
        if (canContinue && anyKey.upCount === 1) menu.callback();
        else if (gameState === GameState.WAITING_FOR_FIRST_CLICK) {
          setTextAlign(ALIGN_CENTER);
          setFontSize(32, "italic");
          drawShadowText("PRESS ANY KEY TO CONTINUE", CENTER_X, HEIGHT - 90);
        } else if (gameState === GameState.AFTER_LEVEL) {
          setTextAlign(ALIGN_CENTER);
          setFontSize(64, "italic");
          drawShadowText(`LEVEL ${level} CLEARED`, CENTER_X, 120);
          setFontSize(48, "italic");
          drawShadowText(gameTime.toFixed(1) + " sec", CENTER_X, 220);
          setFontSize(32, "italic");
          drawShadowText("PRESS ANY KEY TO CONTINUE", CENTER_X, HEIGHT - 90);
        } else {
          drawRectangle(20, HEIGHT - 180, 900, 160, "#cb6", OVERLAY_BLACK);
          const index = gameState === GameState.BEFORE_LEVEL ? level : 0;
          if (DEBUG)
            if (!introText[gameState])
              log("no intro text for gameState: " + gameState);
            else if (!introText[gameState][index])
              log("no intro text for level: " + index);
          setTextAlign(ALIGN_LEFT);
          setFontSize(28, "italic");
          drawText(introText[gameState][index][0], 30, HEIGHT - 165);
          drawText(introText[gameState][index][1], 30, HEIGHT - 122);
          setFontSize(20, "italic");
          drawText("PRESS ANY KEY TO CONTINUE", 30, HEIGHT - 53);
        }
      };
      const rng = new RNG(1);
      const levelDefinitions = [
        () => {
          log("Openening scene");
          entities.push(new Spaceship());
        },
        () => {
          log("Level 1 - Intro level");
          createMetalPlatform(4, 0, 0, 32, 4, 4);
          createCoins(14, 5, 2, 4, 0, 3);
          createMetalPlatform(28, 0, 4, 32, 4, 8);
          createLift(30, 3, 10, 30, 8, 10);
          createMetalPlatform(0, 4, 12, 32, 8, 16);
          createCoins(14, 9, 14, 4, 0, 3);
          createMetalPlatform(0, 4, 16, 4, 8, 20);
          createLift(2, 12, 22, 2, 7, 22);
          createMetalPlatform(0, 8, 24, 16, 12, 28);
          createMetalPlatform(16, 8, 24, 32, 10, 28);
          const alien = new Alien();
          alien.aggroRange = 0;
          vec3.set(alien.pos, 18, 10, 26);
          alien.waypoints = [
            vec3.fromValues(17, 10, 26),
            vec3.fromValues(27, 10, 26),
          ];
          entities.push(alien);
          entities.push(new Flagpole(30, 10, 26));
          vec3.set(player.pos, 6, 4, 2);
        },
        () => {
          log("Level 2 - Maze level");
          createMetalPlatform(12, 3.5, 0, 20, 4.5, 8);
          createMetalPlatform(0, 4, 8, 32, 5, 12);
          createMetalPlatform(8, 4.5, 12, 12, 5.5, 16);
          createMetalPlatform(0, 5, 16, 32, 6, 20);
          createMetalPlatform(20, 5.5, 20, 24, 6.5, 24);
          createMetalPlatform(0, 6, 24, 32, 7, 28);
          createCoins(2, 6, 10, 28, 0, 2);
          createCoins(2, 7, 18, 28, 0, 2);
          createCoins(10, 8, 26, 4, 0, 4);
          const alien1 = new Alien(4, 5, 10);
          alien1.aggroRange = 0;
          alien1.waypoints = [
            vec3.fromValues(4, 5, 10),
            vec3.fromValues(28, 5, 10),
          ];
          entities.push(alien1);
          const alien2 = new Alien(4, 6, 18);
          alien2.aggroRange = 0;
          alien2.waypoints = [
            vec3.fromValues(4, 6, 18),
            vec3.fromValues(28, 6, 18),
          ];
          entities.push(alien2);
          vec3.set(player.pos, 16, 4, 2);
          entities.push(new Flagpole(2, 7, 26));
        },
        () => {
          log("Level 3 - Lotsa lifts");
          createMetalPlatform(0, 0, 0, 4, 4, 36);
          createMetalPlatform(32, 0, 0, 36, 4, 36);
          entities.push(new Fuel(2, 5, 30, 50));
          for (let x = 6; x <= 30; x += 4) {
            const lift = createLift(x, 3, 16, x, 10, 16);
            lift.pos[1] = (x * 2) % 11;
          }
          createCoins(6, 12, 16, 4, 0, 7);
          vec3.set(player.pos, 2, 4, 16);
          entities.push(new Flagpole(34, 4, 16));
        },
        () => {
          log("Level 4 - Four Corners");
          const createCorner = (x, y, z) => {
            createMetalPlatform(x, y, z, x + 12, y + 4, z + 12);
            if (x !== 0 || z !== 0)
              entities.push(new Coin(x + 2, y + 4, z + 2));
            entities.push(new Coin(x + 10, y + 4, z + 2));
            entities.push(new Coin(x + 10, y + 4, z + 10));
            entities.push(new Coin(x + 2, y + 4, z + 10));
            if (y > 0) {
              const alien1 = new Alien(x + 2, y + 4, z + 2);
              alien1.aggroRange = 0;
              alien1.acceleration = 50;
              alien1.waypoints = [
                vec3.fromValues(x + 2, y + 4, z + 2),
                vec3.fromValues(x + 10, y + 4, z + 2),
                vec3.fromValues(x + 10, y + 4, z + 10),
                vec3.fromValues(x + 2, y + 4, z + 10),
              ];
              entities.push(alien1);
            }
          };
          createCorner(0, 0, 0);
          entities.push(new Fuel(6, 5, 6, 20));
          vec3.set(player.pos, 1, 5, 1);
          createCorner(20, 4, 0);
          entities.push(new Fuel(26, 9, 6, 20));
          createCorner(20, 8, 20);
          entities.push(new Fuel(26, 13, 26, 20));
          createCorner(0, 12, 20);
          entities.push(new Flagpole(6, 16, 26));
        },
        () => {
          log("Level 5 - The Pit");
          createMetalPlatform(0, 0, 0, 32, 4, 32);
          createMetalPlatform(0, 4, 0, 32, 8, 4);
          createMetalPlatform(0, 4, 28, 32, 12, 32);
          createMetalPlatform(0, 4, 4, 4, 10, 28);
          createMetalPlatform(28, 4, 4, 32, 8, 28);
          vec3.set(player.pos, 30, 8, 2);
          for (let z = 10; z <= 26; z += 4) {
            const alien1 = new Alien(z, 4, z);
            alien1.color = COLOR_ORANGE;
            alien1.aggroRange = 12;
            alien1.acceleration = 50;
            alien1.waypoints = [
              vec3.fromValues(22, 4, z),
              vec3.fromValues(10, 4, z),
            ];
            entities.push(alien1);
          }
          createLift(6, 4, 26, 6, 15, 26);
          createCoins(6, 5, 10, 0, 4, 4);
          createCoins(26, 5, 10, 0, 4, 4);
          createCoins(10, 13, 30, 4, 0, 4);
          entities.push(new Flagpole(30, 12, 30));
        },
        () => {
          log("Level 6 - Moat and Castle");
          createMetalPlatform(0, 0, 0, 32, 1, 32);
          vec3.set(player.pos, 26, 2, 16);
          createMetalPlatform(0, 0, 28, 32, 6, 32);
          for (let i = 0; i < 10; i++)
            createMetalPlatform(4, 1, 18 + i, 8, 1 + i / 2, 19 + i);
          createLift(2, 5, 26, 2, 5, 6);
          createCoins(2, 7, 10, 0, 4, 4);
          createMetalPlatform(0, 0, 0, 4, 6, 4);
          createLift(26, 5, 2, 6, 5, 2);
          createCoins(10, 7, 2, 4, 0, 4);
          createMetalPlatform(28, 0, 0, 32, 6, 4);
          createLift(30, 5, 26, 30, 5, 6);
          createCoins(30, 7, 10, 0, 4, 4);
          createMetalPlatform(8, 0, 16, 24, 6, 32);
          for (let i = 0; i < 12; i++)
            createMetalPlatform(23 - i, 1, 16, 24 - i, 6 + i / 2, 20);
          createMetalPlatform(8, 1, 16, 12, 12, 20);
          createMetalPlatform(8, 1, 20, 20, 12, 32);
          entities.push(new Flagpole(14, 12, 26));
          const waypoints = [
            vec3.fromValues(10, 12, 30),
            vec3.fromValues(18, 12, 30),
            vec3.fromValues(18, 12, 22),
            vec3.fromValues(10, 12, 22),
          ];
          for (let i = 0; i < 4; i++) {
            const alien1 = new Alien(
              waypoints[i][0],
              waypoints[i][1],
              waypoints[i][2],
            );
            alien1.aggroRange = 0;
            alien1.waypoints = waypoints;
            alien1.waypointIndex = i;
            entities.push(alien1);
          }
        },
        () => {
          log("Level 7 - Firing Squad");
          createMetalPlatform(0, 0, 0, 32, 4, 32);
          for (let z = 4; z <= 28; z += 8)
            for (let x = 4; x <= 28; x += 8) entities.push(new Coin(x, 5, z));
          vec3.set(player.pos, 16, 5, 2);
          let nextShootTime = 0;
          for (let x = 4; x <= 28; x += 8)
            entities.push(
              new Shooter(x, 5, 34, Math.PI, (nextShootTime += 0.5)),
            );
          for (let z = 4; z <= 28; z += 8) {
            let x = -2;
            let yaw = Math.PI / 2;
            if (((z - 4) / 8) % 2 !== 0) {
              x = 34;
              yaw = -yaw;
            }
            entities.push(new Shooter(x, 5, z, yaw, (nextShootTime += 0.5)));
          }
          entities.push(new Flagpole(16, 4, 16));
        },
        () => {
          log("Level 8 - Pyramid");
          createMetalPlatform(0, 0, 0, 32, 4, 32);
          createMetalPlatform(4, 4, 8, 28, 8, 32);
          createMetalPlatform(8, 8, 16, 24, 12, 32);
          createMetalPlatform(12, 12, 24, 20, 16, 32);
          createMetalPlatform(0, 4, 28, 4, 4.7, 32);
          createLift(2, 4.5, 30, 2, 8, 30);
          createMetalPlatform(24, 8, 28, 28, 8.7, 32);
          createLift(26, 8.5, 30, 26, 12, 30);
          createMetalPlatform(8, 12, 28, 12, 12.7, 32);
          createLift(10, 12.5, 30, 10, 16, 30);
          entities.push(new Shooter(-2, 9, 10, Math.PI / 2, 0.5));
          entities.push(new Shooter(-2, 9, 14, Math.PI / 2, 0.5));
          entities.push(new Shooter(-2, 13, 18, Math.PI / 2, 1));
          entities.push(new Shooter(-2, 13, 22, Math.PI / 2, 1));
          entities.push(new Shooter(34, 13, 18, -Math.PI / 2, 1.5));
          entities.push(new Shooter(34, 13, 22, -Math.PI / 2, 1.5));
          const alien1 = new Alien(30, 4, 30);
          alien1.color = COLOR_ORANGE;
          alien1.aggroRange = 12;
          alien1.acceleration = 80;
          alien1.waypoints = [
            vec3.fromValues(30, 4, 30),
            vec3.fromValues(30, 4, 16),
          ];
          entities.push(alien1);
          createCoins(30, 5, 2, 0, 4, 4);
          vec3.set(player.pos, 16, 4, 2);
          entities.push(new Flagpole(16, 16, 30));
        },
        () => {
          log("Level 9 - Spires of Kodo");
          vec3.set(player.pos, 16, 4, 2);
          createMetalPlatform(0, 0, 0, 32, 4, 32);
          createMetalPlatform(0, 4, 24, 8, 32, 32);
          createMetalPlatform(4, 4, 20, 8, 4.7, 24);
          createLift(6, 4.5, 22, 6, 15, 22);
          createLift(2, 24, 22, 2, 13.5, 22);
          createLift(6, 22.5, 22, 6, 33, 22);
          createCoins(2, 33, 26, 4, 0, 2);
          createCoins(2, 33, 30, 4, 0, 2);
          createMetalPlatform(24, 4, 24, 32, 32, 32);
          createLift(10, 31.5, 30, 22, 31.5, 30);
          createLift(22, 31.5, 26, 10, 31.5, 26);
          createCoins(26, 33, 26, 4, 0, 2);
          createCoins(26, 33, 30, 4, 0, 2);
          createMetalPlatform(24, 4, 0, 32, 32, 8);
          createLift(26, 31.5, 10, 26, 31.5, 22);
          createLift(30, 31.5, 22, 30, 31.5, 10);
          createCoins(26, 33, 2, 4, 0, 2);
          createCoins(26, 33, 6, 4, 0, 2);
          entities.push(new Flagpole(28, 32, 4));
        },
        () => {
          log("Level 10 - Kang");
          createMetalPlatform(0, 0, 0, 32, 4, 8);
          createMetalPlatform(0, 4, 4, 8, 8, 8);
          createLift(30, 3.5, 10, 30, 11.5, 10);
          for (let y = 10; y <= 42; y += 16) {
            createMetalPlatform(28, y, 12, 32, y + 2, 32);
            createCoins(30, y + 3, 18, 0, 4, 3);
            entities.push(new Fuel(30, y + 3, 30, 100));
            createMetalPlatform(0, y + 8, 12, 4, y + 10, 32);
            createCoins(2, y + 11, 18, 0, 4, 3);
            entities.push(new Fuel(2, y + 11, 30, 100));
          }
          entities.push(new Flagpole(2, 52, 14));
          entities.push(new Kang());
          vec3.set(player.pos, 2, 4, 2);
        },
        () => {
          log("Level 11 - credits");
          gameState = GameState.CREDITS;
        },
      ];
      const createPlatform = (x1, y1, z1, x2, y2, z2, color) => {
        const platform = new Platform();
        vec3.set(platform.pos, (x1 + x2) / 2, (y1 + y2) / 2, (z1 + z2) / 2);
        vec3.set(platform.scale, (x2 - x1) / 2, (y2 - y1) / 2, (z2 - z1) / 2);
        entities.push(platform);
      };
      const createMetalPlatform = (x1, y1, z1, x2, y2, z2, goombas) => {
        createPlatform(x1, y1, z1, x2, y2, z2, COLOR_SILVER);
        for (let x = x1 + 2; x < x2; x += 4)
          for (let z = z1 + 2; z < z2; z += 4) {
            const m = buffers[STATIC_CUBES].addInstance(COLOR_DARK_BLUE);
            mat4.translate(m, m, vec3.fromValues(x, y2 + 0.01, z));
            mat4.scale(m, m, vec3.fromValues(1.8, 0.02, 1.8));
          }
        const dx = x2 - x1;
        const dz = z2 - z1;
        if (goombas)
          for (let i = 0; i < dx * dz * 0.01; i++) {
            const x = x1 + 0.5 + rng.nextFloat() * (dx - 1);
            const z = z1 + 0.5 + rng.nextFloat() * (dz - 1);
            const alien = new Alien();
            vec3.set(alien.pos, x, y2, z);
            entities.push(alien);
          }
      };
      const createLift = (x1, y1, z1, x2, y2, z2) => {
        const platform = new Platform();
        vec3.set(platform.pos, x1, y1, z1);
        vec3.set(platform.scale, 2, 0.3, 2);
        platform.waypoints = [
          vec3.fromValues(x1, y1, z1),
          vec3.fromValues(x2, y2, z2),
        ];
        entities.push(platform);
        return platform;
      };
      const createCoins = (x1, y1, z1, dx, dz, count) => {
        let x = x1;
        let z = z1;
        for (let i = 0; i < count; i++) {
          const coin = new Coin();
          vec3.set(coin.pos, x, y1, z);
          entities.push(coin);
          x += dx;
          z += dz;
        }
      };
      const createStairs = (x, y, z, dx, dz, count) => {
        for (let i = 0; i < count; i++) {
          createPlatform(x, y, z, x + 4, y + 1, z + 4, COLOR_SILVER);
          x += dx;
          y++;
          z += dz;
        }
      };
      function initGame() {
        buffers.forEach((b) => b.usage === STATIC_DRAW && b.resetBuffers());
        entities.length = 0;
        vec3.set(player.pos, 16, 4, 16);
        vec3.set(player.velocity, 0, 0, 0);
        player.rendered = true;
        player.jetpack = false;
        player.health = 1;
        player.fuel = 0;
        player.yaw = 3;
        player.groundedTime = 0;
        player.shootTime = 0;
        coins = 0;
        lastCoinTime = 0;
        coinSequence = 0;
        entities.push(player);
        stopJetpackSound();
        {
          const m = buffers[STATIC_CUBES].addInstance(COLOR_STARS);
          mat4.scale(m, m, vec3.fromValues(500, 500, 500));
        }
        const levelDef = levelDefinitions[level % levelDefinitions.length];
        levelDef();
        availableCoins = entities.filter((e) => e instanceof Coin).length;
        buffers.forEach((b) => b.usage === STATIC_DRAW && b.updateBuffers());
      }
      const cameraTarget = vec3.fromValues(0, 0, 0);
      const preferredCameraPosition = vec3.fromValues(0, 0, 0);
      const lightPosition = vec3.fromValues(200, 400, -32);
      const cubeGeometry = buildRoundedCube(1, 2);
      const sphereGeometry = buildRoundedCube(21, 1);
      buffers.push(
        new BufferSet(STATIC_DRAW, cubeGeometry, 2e5),
        new BufferSet(STATIC_DRAW, sphereGeometry, 1e3),
        new BufferSet(DYNAMIC_DRAW, cubeGeometry, 4e3),
        new BufferSet(DYNAMIC_DRAW, sphereGeometry, 2e3),
      );
      const entities = [];
      const player = new Hero();
      const cameraDistance = 52;
      let coins = 0;
      let availableCoins = 0;
      let lastCoinTime = 0;
      let coinSequence = 0;
      function throwaway() {
        gameState = GameState.PLAYING;
        coins++;
        availableCoins++;
        lastCoinTime++;
        coinSequence++;
      }
      let level = 0;
      let lastEngineBurst = 0;
      const GameState = {
        WAITING_FOR_FIRST_CLICK: 0,
        INTRO_STORY1: 1,
        INTRO_STORY2: 2,
        BEFORE_LEVEL: 3,
        PLAYING: 4,
        AFTER_LEVEL: 5,
        MAIN_MENU: 99,
        CREDITS: 100,
      };
      let gameState = GameState.WAITING_FOR_FIRST_CLICK;
      initGame();
      registerSong("Milky Way by Ben Prunty", milkyWaySong);
      function setLevel(l) {
        level = l;
      }
      const flyoverCamera = () => {
        const theta = 0.2 * time;
        const rho = 0.05 * time;
        const radius = 50 + 20 * Math.sin(0.2 * time);
        const x = radius * Math.sin(rho) * Math.sin(theta);
        const y = radius * Math.abs(Math.cos(rho));
        const z = radius * Math.sin(rho) * Math.cos(theta);
        vec3.set(camera.source, x, y, z);
      };
      function update() {
        updateWorld();
        if (menu !== mainMenu && isKeyPressed(KEY_ESCAPE)) {
          resetKeys();
          setMenu(mainMenu);
          playMenuBeep();
        }
        if (menu) drawMenu();
        else {
          handleInput();
          drawHud();
        }
        if (DEBUG) drawDebugOverlay();
        if (gameState === GameState.CREDITS) {
          player.yaw = 0;
          player.jetpack = true;
          vec3.lerp(
            camera.source,
            camera.source,
            vec3.fromValues(0, 50, -15),
            0.01,
          );
          vec3.lerp(player.pos, player.pos, vec3.fromValues(0, 80, 0), 0.01);
          vec3.set(player.velocity, 0, 0, 0);
          lookAt(
            camera,
            camera.source,
            vec3.fromValues(player.pos[0], player.pos[1] + 15, player.pos[2]),
            0.4,
          );
          createJetpackParticles();
        } else if (gameState === GameState.AFTER_LEVEL) {
          player.yaw += 5 * dt;
          player.jetpack = true;
          vec3.lerp(
            camera.source,
            camera.source,
            vec3.fromValues(0, 90, -25),
            0.01,
          );
          vec3.lerp(player.pos, player.pos, vec3.fromValues(0, 80, 0), 0.01);
          vec3.set(player.velocity, 0, 0, 0);
          cameraTarget[0] = player.pos[0];
          cameraTarget[1] = player.pos[1] + 2;
          cameraTarget[2] = player.pos[2];
          lookAt(camera, camera.source, cameraTarget, 0.4);
          createJetpackParticles();
        } else if (
          gameState === GameState.BEFORE_LEVEL ||
          gameState === GameState.PLAYING
        ) {
          lightSource[0] = player.pos[0] + 8;
          lightSource[1] = 80;
          lightSource[2] = player.pos[2] - 16;
          cameraTarget[0] = 0.5 * 16 + 0.5 * player.pos[0];
          cameraTarget[1] = 0.9 * cameraTarget[1] + 0.1 * player.pos[1];
          cameraTarget[2] = 0.25 * 16 + 0.75 * player.pos[2];
          vec3.set(
            preferredCameraPosition,
            0.2 * 16 + 0.8 * cameraTarget[0],
            cameraTarget[1] + cameraDistance,
            0.25 * 8 + 0.75 * cameraTarget[2] - cameraDistance,
          );
          camera.source[0] = preferredCameraPosition[0];
          vec3.lerp(
            camera.source,
            camera.source,
            preferredCameraPosition,
            0.02,
          );
          lookAt(camera, camera.source, cameraTarget, 0.4);
        } else if (gameState <= GameState.INTRO_STORY2) {
          flyoverCamera();
          vec3.set(cameraTarget, 0, 0, 0);
          lookAt(camera, camera.source, cameraTarget, 0.4);
          player.pos[1] = 400;
          player.velocity[1] = 0;
          if (time - lastEngineBurst > 0.08) {
            lastEngineBurst = time;
            const leftBurst = new Particle();
            const rightBurst = new Particle();
            leftBurst.size = rightBurst.size = 0.25;
            leftBurst.color = rightBurst.color = 4294901808;
            vec3.set(leftBurst.pos, -6, 0.3, 0.7);
            vec3.set(leftBurst.velocity, -10, 0, 0);
            vec3.set(rightBurst.pos, -6, 0.3, -0.7);
            vec3.set(rightBurst.velocity, -10, 0, 0);
            entities.push(leftBurst, rightBurst);
          }
        }
        lookAt(lightSource, lightPosition, vec3.fromValues(16, 0, 16), 0.1);
        renderEntities(entities);
      }
      function inRangeOfPlayer(entity) {
        return (
          entity.pos[0] > player.pos[0] - 20 &&
          entity.pos[0] < player.pos[0] + 20 &&
          entity.pos[2] > player.pos[2] - 15 &&
          entity.pos[2] < player.pos[2] + 40
        );
      }
      function renderEntities(entities) {
        resetLights();
        for (let i = entities.length - 1; i >= 0; i--) {
          const entity = entities[i];
          if (entity !== player && entity.health <= 0) {
            entities.splice(i, 1);
            continue;
          }
          if (entity.rendered) {
            entity.setupTransformMatrix();
            entity.render();
          }
        }
      }
      function playerDie() {
        playMusic(deathSongData);
        stopJetpackSound();
        setMenu(deathScreen);
      }
      function handleInput() {
        player.accelerating = false;
        if (
          gameState !== GameState.AFTER_LEVEL &&
          gameState !== GameState.CREDITS
        ) {
          if (isKeyDown(KEY_UP) || isKeyDown(KEY_W)) {
            player.velocity[2] += dt * ACCELERATION;
            player.accelerating = true;
          }
          if (isKeyDown(KEY_DOWN) || isKeyDown(KEY_S)) {
            player.velocity[2] -= dt * ACCELERATION;
            player.accelerating = true;
          }
          if (isKeyDown(KEY_LEFT) || isKeyDown(KEY_A)) {
            player.velocity[0] -= dt * ACCELERATION;
            player.accelerating = true;
          }
          if (isKeyDown(KEY_RIGHT) || isKeyDown(KEY_D)) {
            player.velocity[0] += dt * ACCELERATION;
            player.accelerating = true;
          }
          if ((isKeyDown(KEY_X) || isKeyDown(KEY_SHIFT)) && player.fuel > 0) {
            player.velocity[1] += dt * 60;
            player.jetpack = true;
            player.fuel = Math.max(0, player.fuel - dt * 20);
            createJetpackParticles();
          } else player.jetpack = false;
          if (player.jetpack && !jetpackSound) startJetpackSound();
          if (!player.jetpack && jetpackSound) stopJetpackSound();
          if (
            player.isGrounded() &&
            (keys[KEY_Z].downCount === 1 || keys[KEY_SPACE].downCount === 1)
          )
            player.jump();
          if (isKeyPressed(KEY_R)) playerDie();
          if (isKeyPressed(KEY_M)) toggleBackgroundMusic();
        }
      }
      function createJetpackParticles() {
        if (Math.random() < 0.3) {
          const blast = new Particle();
          blast.size = 0.2;
          blast.velocity[1] =
            gameState === GameState.AFTER_LEVEL ||
            gameState === GameState.CREDITS
              ? -10
              : -0.3;
          vec3.copy(blast.pos, player.pos);
          blast.pos[0] -= 0.3 * Math.sin(player.yaw);
          blast.pos[1] += 0.8;
          blast.pos[2] -= 0.3 * Math.cos(player.yaw);
          entities.push(blast);
        }
      }
      function updateWorld() {
        if (Math.random() < 0.02) {
          const floaty = new Particle();
          floaty.size = 0.08;
          floaty.velocity[1] = 1;
          vec3.copy(floaty.pos, player.pos);
          floaty.pos[0] += (Math.random() - 0.5) * 30;
          floaty.pos[2] += (Math.random() - 0.5) * 30;
          entities.push(floaty);
        }
        if (gameTime - lastCoinTime > 1) coinSequence = 0;
        for (let i = 0; i < entities.length; i++) entities[i].update();
        const playerWasAlive = player.health > 0;
        for (let i = 0; i < entities.length; i++)
          for (let j = 0; j < entities.length; j++) {
            if (
              entities[i] instanceof Platform &&
              !(entities[j] instanceof Platform)
            ) {
              const platform = entities[i];
              const actor = entities[j];
              const actorX = actor.pos[0];
              const actorY = actor.pos[1];
              const actorZ = actor.pos[2];
              const projectile =
                actor instanceof Particle && actor.projectile > 0;
              const actorRadius = projectile ? 0.1 : 0.7;
              const actorHeight = projectile ? 0.1 : 2.5;
              const platformMinX =
                platform.pos[0] - platform.scale[0] - actorRadius;
              const platformMinY = platform.pos[1] - platform.scale[1];
              const platformMinZ =
                platform.pos[2] - platform.scale[2] - actorRadius;
              const platformMaxX =
                platform.pos[0] + platform.scale[0] + actorRadius;
              const platformMaxY = platform.pos[1] + platform.scale[1];
              const platformMaxZ =
                platform.pos[2] + platform.scale[2] + actorRadius;
              const graceY = 1;
              if (
                actorX > platformMinX &&
                actorX < platformMaxX &&
                actorZ > platformMinZ &&
                actorZ < platformMaxZ
              )
                if (
                  projectile &&
                  actorY < platformMaxY &&
                  actorY > platformMinY
                )
                  actor.health = 0;
                else if (
                  actorY > platformMaxY - graceY &&
                  actorY < platformMaxY
                ) {
                  actor.pos[1] = platformMaxY;
                  if (actor.velocity[1] < 0) {
                    actor.velocity[1] = 0;
                    actor.groundedTime = gameTime;
                    actor.groundedPlatform = platform;
                  }
                } else if (
                  actorY < platformMaxY &&
                  actorY + actorHeight > platformMinY
                )
                  if (actorX < platform.pos[0] - platform.scale[0])
                    actor.pos[0] = platformMinX;
                  else if (actorX > platform.pos[0] + platform.scale[0])
                    actor.pos[0] = platformMaxX;
                  else if (actorZ < platform.pos[2] - platform.scale[2])
                    actor.pos[2] = platformMinZ;
                  else actor.pos[2] = platformMaxZ;
            }
            vec3.copy(tempVec, player.pos);
            tempVec[1] += 1;
            if (
              entities[i] instanceof Hero &&
              entities[j] instanceof Particle &&
              entities[j].projectile === ProjectileType.Enemy &&
              vec3.distance(tempVec, entities[j].pos) < 1.5 &&
              gameState === GameState.PLAYING
            ) {
              player.health = 0;
              player.rendered = false;
              entities[j].health = 0;
              playExplosionSound();
              createExplosion(player.pos, COLOR_WHITE);
            }
          }
        updateEntity(player);
        if (playerWasAlive && player.health <= 0) playerDie();
      }
      function createExplosion(startPos, color = COLOR_WHITE, count = 40) {
        log("Create explosion");
        for (let k = 0; k < count; k++) {
          const explosion = new Particle();
          vec3.copy(explosion.pos, startPos);
          explosion.pos[1] += 1;
          explosion.color = color;
          explosion.size = 0.4;
          const speed = 0.2 + Math.random() * 5;
          const direction = Math.random() * 6.28;
          explosion.velocity[0] = Math.sin(direction) * speed;
          explosion.velocity[1] = 2;
          explosion.velocity[2] = Math.cos(direction) * speed;
          explosion.acceleration[1] = -0.5;
          entities.push(explosion);
        }
      }
      function updateEntity(entity) {
        if (entity.isGrounded() && entity.groundedPlatform)
          vec3.scaleAndAdd(
            entity.pos,
            entity.pos,
            entity.groundedPlatform.velocity,
            dt,
          );
        entity.velocity[0] *= 1 - dt * FRICTION;
        entity.velocity[2] *= 1 - dt * FRICTION;
        entity.pos[0] += dt * entity.velocity[0];
        entity.pos[2] += dt * entity.velocity[2];
        const speed = vec3.magnitude(entity.velocity);
        if (vec3.magnitude(entity.velocity) > 0.1)
          entity.yaw = Math.atan2(entity.velocity[0], entity.velocity[2]);
        else vec3.set(entity.velocity, 0, 0, 0);
        if (gameState === GameState.CREDITS) {
          player.yaw = 0;
          if (Math.random() < 0.5) {
            const box = new Mystery(
              (Math.random() < 0.5 ? -1 : 1) * (10 + 40 * Math.random()),
              600,
              (Math.random() < 0.5 ? -1 : 1) * (10 + 40 * Math.random()),
              2 + 2 * Math.random(),
              4 + 20 * Math.random(),
              2 + 2 * Math.random(),
            );
            box.velocity[1] = -100 - 400 * Math.random();
            entities.push(box);
          }
        } else if (gameState !== GameState.AFTER_LEVEL) {
          const gravity = GRAVITY;
          entity.velocity[1] -= dt * gravity;
          entity.pos[1] += dt * entity.velocity[1];
        }
        if (entity.isGrounded() && speed > 5 && Math.random() < 0.2) {
          const dust = new Particle();
          dust.velocity[1] = 0.1;
          vec3.copy(dust.pos, entity.pos);
          entities.push(dust);
        }
        if (entity.pos[1] < -30) {
          entity.pos[1] = -30;
          entity.health = 0;
        }
      }
      const bestTimesStr = localStorage["callisto-times"];
      const bestTimes = bestTimesStr ? JSON.parse(bestTimesStr) : [];
    </script>

    <script type="module">
      const platformInfo = await ext.runtime.getPlatformInfo();
      const webview = await ext.webviews.getCurrent();
      const window = await ext.webviews.getAttachedWindow(webview.id);
      const insetSize = await ext.windows.getInsetSize(window.id);

      OS = platformInfo.os;

      if (platformInfo.os !== "mac" && insetSize) {
        document.getElementById("frame").style.right = insetSize.width;
      }
    </script>
  </body>
</html>
